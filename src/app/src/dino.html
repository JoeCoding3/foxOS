<!DOCTYPE html>
<html class="offline">
  <head>
    <title>Chrome Dino Game</title>
    <style>
      a {
        color: var(--link-color);
      }
      
      body {
        --background-color: #fff;
        --error-code-color: var(--google-gray-700);
        --google-blue-100: rgb(210, 227, 252);
        --google-blue-300: rgb(138, 180, 248);
        --google-blue-600: rgb(26, 115, 232);
        --google-blue-700: rgb(25, 103, 210);
        --google-gray-100: rgb(241, 243, 244);
        --google-gray-300: rgb(218, 220, 224);
        --google-gray-500: rgb(154, 160, 166);
        --google-gray-50: rgb(248, 249, 250);
        --google-gray-600: rgb(128, 134, 139);
        --google-gray-700: rgb(95, 99, 104);
        --google-gray-800: rgb(60, 64, 67);
        --google-gray-900: rgb(32, 33, 36);
        --heading-color: var(--google-gray-900);
        --link-color: rgb(88, 88, 88);
        --popup-container-background-color: rgba(0,0,0,.65);
        --primary-button-fill-color-active: var(--google-blue-700);
        --primary-button-fill-color: var(--google-blue-600);
        --primary-button-text-color: #fff;
        --quiet-background-color: rgb(247, 247, 247);
        --secondary-button-border-color: var(--google-gray-500);
        --secondary-button-fill-color: #fff;
        --secondary-button-hover-border-color: var(--google-gray-600);
        --secondary-button-hover-fill-color: var(--google-gray-50);
        --secondary-button-text-color: var(--google-gray-700);
        --small-link-color: var(--google-gray-700);
        --text-color: var(--google-gray-700);
        background: var(--background-color);
        color: var(--text-color);
        word-wrap: break-word;
      }
      
      .nav-wrapper .secondary-button {
        background: var(--secondary-button-fill-color);
        border: 1px solid var(--secondary-button-border-color);
        color: var(--secondary-button-text-color);
        float: none;
        margin: 0;
        padding: 8px 16px;
      }
      
      .hidden {
        display: none;
      }
      
      html {
        -webkit-text-size-adjust: 100%;
        font-size: 125%;
      }
      
      .icon {
        background-repeat: no-repeat;
        background-size: 100%;
      }
      
      @media (prefers-color-scheme: dark) {
        body {
          --background-color: var(--google-gray-900);
          --error-code-color: var(--google-gray-500);
          --heading-color: var(--google-gray-500);
          --link-color: var(--google-blue-300);
          --primary-button-fill-color-active: rgb(129, 162, 208);
          --primary-button-fill-color: var(--google-blue-300);
          --primary-button-text-color: var(--google-gray-900);
          --quiet-background-color: var(--background-color);
          --secondary-button-border-color: var(--google-gray-700);
          --secondary-button-fill-color: var(--google-gray-900);
          --secondary-button-hover-fill-color: rgb(48, 51, 57);
          --secondary-button-text-color: var(--google-blue-300);
          --small-link-color: var(--google-blue-300);
          --text-color: var(--google-gray-500);
        }
      }
      button {
        border: 0;
        border-radius: 20px;
        box-sizing: border-box;
        color: var(--primary-button-text-color);
        cursor: pointer;
        float: right;
        font-size: .875em;
        margin: 0;
        padding: 8px 16px;
        transition: box-shadow 150ms cubic-bezier(0.4, 0, 0.2, 1);
        user-select: none;
      }
      
      [dir='rtl'] button {
        float: left;
      }
      
      .bad-clock button,
      .captive-portal button,
      .https-only button,
      .insecure-form button,
      .lookalike-url button,
      .neterror button,
      .pdf button,
      .ssl button,
      .safe-browsing-billing button {
        background: var(--primary-button-fill-color);
      }
      
      button:active {
        background: var(--primary-button-fill-color-active);
        outline: 0;
      }
      
      #debugging {
        display: inline;
        overflow: auto;
      }
      
      .debugging-content {
        line-height: 1em;
        margin-bottom: 0;
        margin-top: 1em;
      }
      
      .debugging-content-fixed-width {
        display: block;
        font-family: monospace;
        font-size: 1.2em;
        margin-top: 0.5em;
      }
      
      .debugging-title {
        font-weight: bold;
      }
      
      #details {
        margin: 0 0 50px;
      }
      
      #details p:not(:first-of-type) {
        margin-top: 20px;
      }
      
      .secondary-button:active {
        border-color: white;
        box-shadow: 0 1px 2px 0 rgba(60, 64, 67, .3),
            0 2px 6px 2px rgba(60, 64, 67, .15);
      }
      
      .secondary-button:hover {
        background: var(--secondary-button-hover-fill-color);
        border-color: var(--secondary-button-hover-border-color);
        text-decoration: none;
      }
      
      .error-code {
        color: var(--error-code-color);
        font-size: .8em;
        margin-top: 12px;
        text-transform: uppercase;
      }
      
      #error-debugging-info {
        font-size: 0.8em;
      }
      
      h1 {
        color: var(--heading-color);
        font-size: 1.6em;
        font-weight: normal;
        line-height: 1.25em;
        margin-bottom: 16px;
      }
      
      h2 {
        font-size: 1.2em;
        font-weight: normal;
      }
      
      .icon {
        height: 72px;
        margin: 0 0 40px;
        width: 72px;
      }
      
      input[type=checkbox] {
        opacity: 0;
      }
      
      input[type=checkbox]:focus ~ .checkbox::after {
        outline: -webkit-focus-ring-color auto 5px;
      }
      
      .interstitial-wrapper {
        box-sizing: border-box;
        font-size: 1em;
        line-height: 1.6em;
        margin: 14vh auto 0;
        max-width: 600px;
        width: 100%;
      }
      
      #main-message > p {
        display: inline;
      }
      
      #extended-reporting-opt-in {
        font-size: .875em;
        margin-top: 32px;
      }
      
      #extended-reporting-opt-in label {
        display: grid;
        grid-template-columns: 1.8em 1fr;
        position: relative;
      }
      
      #enhanced-protection-message {
        border-radius: 20px;
        font-size: 1em;
        margin-top: 32px;
        padding: 10px 5px;
      }
      
      #enhanced-protection-message a {
        color: var(--google-red-10);
      }
      
      #enhanced-protection-message label {
        display: grid;
        grid-template-columns: 2.5em 1fr;
        position: relative;
      }
      
      #enhanced-protection-message div {
        margin: 0.5em;
      }
      
      #enhanced-protection-message .icon {
        height: 1.5em;
        vertical-align: middle;
        width: 1.5em;
      }
      
      .nav-wrapper {
        margin-top: 51px;
      }
      
      .nav-wrapper::after {
        clear: both;
        content: '';
        display: table;
        width: 100%;
      }
      
      .small-link {
        color: var(--small-link-color);
        font-size: .875em;
      }
      
      .checkboxes {
        flex: 0 0 24px;
      }
      
      .checkbox {
        --padding: .9em;
        background: transparent;
        display: block;
        height: 1em;
        left: -1em;
        padding-inline-start: var(--padding);
        position: absolute;
        right: 0;
        top: -.5em;
        width: 1em;
      }
      
      .checkbox::after {
        border: 1px solid white;
        border-radius: 2px;
        content: '';
        height: 1em;
        left: var(--padding);
        position: absolute;
        top: var(--padding);
        width: 1em;
      }
      
      .checkbox::before {
        background: transparent;
        border: 2px solid white;
        border-inline-end-width: 0;
        border-top-width: 0;
        content: '';
        height: .2em;
        left: calc(.3em + var(--padding));
        opacity: 0;
        position: absolute;
        top: calc(.3em  + var(--padding));
        transform: rotate(-45deg);
        width: .5em;
      }
      
      input[type=checkbox]:checked ~ .checkbox::before {
        opacity: 1;
      }
      
      #recurrent-error-message {
        background: #ededed;
        border-radius: 4px;
        margin-bottom: 16px;
        margin-top: 12px;
        padding: 12px 16px;
      }
      
      .showing-recurrent-error-message #extended-reporting-opt-in {
        margin-top: 16px;
      }
      
      .showing-recurrent-error-message #enhanced-protection-message {
        margin-top: 16px;
      }
      
      @media (max-width: 700px) {
        .interstitial-wrapper {
          padding: 0 10%;
        }
      
        #error-debugging-info {
          overflow: auto;
        }
      }
      
      @media (max-width: 420px) {
        button,
        [dir='rtl'] button,
        .small-link {
          float: none;
          font-size: .825em;
          font-weight: 500;
          margin: 0;
          width: 100%;
        }
      
        button {
          padding: 16px 24px;
        }
      
        #details {
          margin: 20px 0 20px 0;
        }
      
        #details p:not(:first-of-type) {
          margin-top: 10px;
        }
      
        .secondary-button:not(.hidden) {
          display: block;
          margin-top: 20px;
          text-align: center;
          width: 100%;
        }
      
        .interstitial-wrapper {
          padding: 0 5%;
        }
      
        #extended-reporting-opt-in {
          margin-top: 24px;
        }
      
        #enhanced-protection-message {
          margin-top: 24px;
        }
      
        .nav-wrapper {
          margin-top: 30px;
        }
      }
      
      /* Fixed nav. */
      @media (min-width: 240px) and (max-width: 420px) and
            (min-height: 401px),
            (min-width: 421px) and (min-height: 240px) and
            (max-height: 560px) {
        body .nav-wrapper {
          background: var(--background-color);
          bottom: 0;
          box-shadow: 0 -12px 24px var(--background-color);
          left: 0;
          margin: 0 auto;
          max-width: 736px;
          padding-inline-end: 24px;
          padding-inline-start: 24px;
          position: fixed;
          right: 0;
          width: 100%;
          z-index: 2;
        }
      
        .interstitial-wrapper {
          max-width: 736px;
        }
      
        #details,
        #main-content {
          padding-bottom: 40px;
        }
      
        #details {
          padding-top: 5.5vh;
        }
      
        button.small-link {
          color: var(--google-blue-600);
        }
      }
      
      @media (max-width: 420px) and (orientation: portrait),
            (max-height: 560px) {
        body {
          margin: 0 auto;
        }
      
        button,
        [dir='rtl'] button,
        button.small-link,
        .nav-wrapper .secondary-button {
          font-family: Roboto-Regular,Helvetica;
          font-size: .933em;
          margin: 6px 0;
          transform: translatez(0);
        }
      
        .nav-wrapper {
          box-sizing: border-box;
          padding-bottom: 8px;
          width: 100%;
        }
      
        #details {
          box-sizing: border-box;
          height: auto;
          margin: 0;
          opacity: 1;
          transition: opacity 250ms cubic-bezier(0.4, 0, 0.2, 1);
        }
      
        #details.hidden,
        #main-content.hidden {
          height: 0;
          opacity: 0;
          overflow: hidden;
          padding-bottom: 0;
          transition: none;
        }
      
        h1 {
          font-size: 1.5em;
          margin-bottom: 8px;
        }
      
        .icon {
          margin-bottom: 5.69vh;
        }
      
        .interstitial-wrapper {
          box-sizing: border-box;
          margin: 7vh auto 12px;
          padding: 0 24px;
          position: relative;
        }
      
        .interstitial-wrapper p {
          font-size: .95em;
          line-height: 1.61em;
          margin-top: 8px;
        }
      
        #main-content {
          margin: 0;
          transition: opacity 100ms cubic-bezier(0.4, 0, 0.2, 1);
        }
      
        .small-link {
          border: 0;
        }
      
        .suggested-left > #control-buttons,
        .suggested-right > #control-buttons {
          float: none;
          margin: 0;
        }
      }
      
      @media (min-width: 421px) and (min-height: 500px) and (max-height: 560px) {
        .interstitial-wrapper {
          margin-top: 10vh;
        }
      }
      
      @media (min-height: 400px) and (orientation:portrait) {
        .interstitial-wrapper {
          margin-bottom: 145px;
        }
      }
      
      @media (min-height: 299px) {
        .nav-wrapper {
          padding-bottom: 16px;
        }
      }
      
      @media (max-height: 560px) and (min-height: 240px) and (orientation:landscape) {
        .extended-reporting-has-checkbox #details {
          padding-bottom: 80px;
        }
      }
      
      @media (min-height: 500px) and (max-height: 650px) and (max-width: 414px) and
            (orientation: portrait) {
        .interstitial-wrapper {
          margin-top: 7vh;
        }
      }
      
      @media (min-height: 650px) and (max-width: 414px) and (orientation: portrait) {
        .interstitial-wrapper {
          margin-top: 10vh;
        }
      }
      
      @media (max-width: 239px) and (orientation: portrait) {
        .nav-wrapper {
          padding-inline-end: 0;
          padding-inline-start: 0;
        }
      }
      /* Don't use the main frame div when the error is in a subframe. */
      html[subframe] #main-frame-error {
        display: none;
      }
      
      /* Don't use the subframe error div when the error is in a main frame. */
      html:not([subframe]) #sub-frame-error {
        display: none;
      }
      
      h1 {
        margin-top: 0;
        word-wrap: break-word;
      }
      
      h1 span {
        font-weight: 500;
      }
      
      a {
        text-decoration: none;
      }
      
      .icon {
        user-select: none;
        display: inline-block;
      }
      
      .icon-generic {
        /* Can't access chrome://theme/IDR_ERROR_NETWORK_GENERIC from an untrusted
        * renderer process, so embed the resource manually. */
        content: -webkit-image-set(
            url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEgAAABIAQMAAABvIyEEAAAABlBMVEUAAABTU1OoaSf/AAAAAXRSTlMAQObYZgAAAENJREFUeF7tzbEJACEQRNGBLeAasBCza2lLEGx0CxFGG9hBMDDxRy/72O9FMnIFapGylsu1fgoBdkXfUHLrQgdfrlJN1BdYBjQQm3UAAAAASUVORK5CYII=) 1x,
            url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJAAAACQAQMAAADdiHD7AAAABlBMVEUAAABTU1OoaSf/AAAAAXRSTlMAQObYZgAAAFJJREFUeF7t0cENgDAMQ9FwYgxG6WjpaIzCCAxQxVggFuDiCvlLOeRdHR9yzjncHVoq3npu+wQUrUuJHylSTmBaespJyJQoObUeyxDQb3bEm5Au81c0pSCD8HYAAAAASUVORK5CYII=) 2x);
      }
      
      .icon-info {
        content: -webkit-image-set(
            url(data:image/png;base64,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) 1x,
            url(data:image/png;base64,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) 2x);
      }
      
      .icon-offline {
        content: -webkit-image-set(
            url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEgAAABIAQMAAABvIyEEAAAABlBMVEUAAABTU1OoaSf/AAAAAXRSTlMAQObYZgAAAGxJREFUeF7tyMEJwkAQRuFf5ipMKxYQiJ3Z2nSwrWwBA0+DQZcdxEOueaePp9+dQZFB7GpUcURSVU66yVNFj6LFICatThZB6r/ko/pbRpUgilY0Cbw5sNmb9txGXUKyuH7eV25x39DtJXUNPQGJtWFV+BT/QAAAAABJRU5ErkJggg==) 1x,
            url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJAAAACQBAMAAAAVaP+LAAAAGFBMVEUAAABTU1NNTU1TU1NPT09SUlJSUlJTU1O8B7DEAAAAB3RSTlMAoArVKvVgBuEdKgAAAJ1JREFUeF7t1TEOwyAMQNG0Q6/UE+RMXD9d/tC6womIFSL9P+MnAYOXeTIzMzMzMzMzaz8J9Ri6HoITmuHXhISE8nEh9yxDh55aCEUoTGbbQwjqHwIkRAEiIaG0+0AA9VBMaE89Rogeoww936MQrWdBr4GN/z0IAdQ6nQ/FIpRXDwHcA+JIJcQowQAlFUA0MfQpXLlVQfkzR4igS6ENjknm/wiaGhsAAAAASUVORK5CYII=) 2x);
        position: relative;
      }
      
      .icon-disabled {
        content: -webkit-image-set(
            url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHAAAABICAMAAAAZF4G5AAAABlBMVEVMaXFTU1OXUj8tAAAAAXRSTlMAQObYZgAAASZJREFUeAHd11Fq7jAMRGGf/W/6PoWB67YMqv5DybwG/CFjRuR8JBw3+ByiRjgV9W/TJ31P0tBfC6+cj1haUFXKHmVJo5wP98WwQ0ZCbfUc6LQ6VuUBz31ikADkLMkDrfUC4rR6QGW+gF6rx7NaHWCj1Y/W6lf4L7utvgBSt3rBFSS/XBMPUILcJINHCBWYUfpWn4NBi1ZfudIc3rf6/NGEvEA+AsYTJozmXemjXeLZAov+mnkN2HfzXpMSVQDnGw++57qNJ4D1xitA2sJ+VAWMygSEaYf2mYPTjZfk2K8wmP7HLIH5Mg4/pP+PEcDzUvDMvYbs/2NWwPO5vBdMZE4EE5UTQLiBFDaUlTDPBRoJ9HdAYIkIo06og3BNXtCzy7zA1aXk5x+tJARq63eAygAAAABJRU5ErkJggg==) 1x,
            url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAOAAAACQAQMAAAArwfVjAAAABlBMVEVMaXFTU1OXUj8tAAAAAXRSTlMAQObYZgAAAYdJREFUeF7F1EFqwzAUBNARAmVj0FZe5QoBH6BX+dn4GlY2PYNzGx/A0CvkCIJuvIraKJKbgBvzf2g62weDGD7CYggpfFReis4J0ey9EGFIiEQQojFSlA9kSIiqd0KkFjKsewgRbStEN19mxUPTtmW9HQ/h6tyqNQ8NlSMZdzyE6qkoE0trVYGFm0n1WYeBhduzwbwBC7voS+vIxfeMjeaiLxsMMtQNwMPtuew+DjzcTHk8YMfDknEcIUOtf2lVfgVH3K4Xv5PRYAXRVMtItIJ3rfaCIVn9DsTH2NxisAVRex2Hh3hX+/mRUR08bAwPEYsI51ZxWH4Q0SpicQRXeyEaIug48FEdegARfMz/tADVsRciwTAxW308ehmC2gLraC+YCbV3QoTZexa+zegAEW5PhhgYfmbvJgcRqngGByOSXdFJcLk2JeDPEN0kxe1JhIt5FiFA+w+ItMELsUyPF2IaJ4aILqb4FbxPwhImwj6JauKgDUCYaxmYIsd4KXdMjIC9ItB5Bn4BNRwsG0XM2nwAAAAASUVORK5CYII=) 2x);
        width: 112px;
      }
      
      .hidden {
        display: none;
      }
      
      #suggestions-list a {
        color: var(--google-blue-600);
      }
      
      #suggestions-list p {
        margin-block-end: 0;
      }
      
      #suggestions-list ul {
        margin-top: 0;
      }
      
      .single-suggestion {
        list-style-type: none;
        padding-inline-start: 0;
      }
      
      #error-information-button {
        content: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBmaWxsPSJub25lIiBkPSJNMCAwaDI0djI0SDB6Ii8+PHBhdGggZD0iTTExIDE4aDJ2LTJoLTJ2MnptMS0xNkM2LjQ4IDIgMiA2LjQ4IDIgMTJzNC40OCAxMCAxMCAxMCAxMC00LjQ4IDEwLTEwUzE3LjUyIDIgMTIgMnptMCAxOGMtNC40MSAwLTgtMy41OS04LThzMy41OS04IDgtOCA4IDMuNTkgOCA4LTMuNTkgOC04IDh6bTAtMTRjLTIuMjEgMC00IDEuNzktNCA0aDJjMC0xLjEuOS0yIDItMnMyIC45IDIgMmMwIDItMyAxLjc1LTMgNWgyYzAtMi4yNSAzLTIuNSAzLTUgMC0yLjIxLTEuNzktNC00LTR6Ii8+PC9zdmc+);
        height: 24px;
        vertical-align: -.15em;
        width: 24px;
      }
      
      .use-popup-container#error-information-popup-container
        #error-information-popup {
        align-items: center;
        background-color: var(--popup-container-background-color);
        display: flex;
        height: 100%;
        left: 0;
        position: fixed;
        top: 0;
        width: 100%;
        z-index: 100;
      }
      
      .use-popup-container#error-information-popup-container
        #error-information-popup-content > p {
        margin-bottom: 11px;
        margin-inline-start: 20px;
      }
      
      .use-popup-container#error-information-popup-container #suggestions-list ul {
        margin-inline-start: 15px;
      }
      
      .use-popup-container#error-information-popup-container
        #error-information-popup-box {
        background-color: var(--background-color);
        left: 5%;
        padding-bottom: 15px;
        padding-top: 15px;
        position: fixed;
        width: 90%;
        z-index: 101;
      }
      
      .use-popup-container#error-information-popup-container div.error-code {
        margin-inline-start: 20px;
      }
      
      .use-popup-container#error-information-popup-container #suggestions-list p {
        margin-inline-start: 20px;
      }
      
      :not(.use-popup-container)#error-information-popup-container
        #error-information-popup-close {
        display: none;
      }
      
      #error-information-popup-close {
        margin-bottom: 0;
        margin-inline-end: 35px;
        margin-top: 15px;
        text-align: end;
      }
      
      .link-button {
        color: rgb(66, 133, 244);
        display: inline-block;
        font-weight: bold;
        text-transform: uppercase;
      }
      
      #sub-frame-error-details {
      
        color: #8F8F8F;
      
        text-shadow: 0 1px 0 rgba(255,255,255,0.3);
      
      }
      
      [jscontent=hostName],
      [jscontent=failedUrl] {
        overflow-wrap: break-word;
      }
      
      .secondary-button {
        background: #d9d9d9;
        color: #696969;
        margin-inline-end: 16px;
      }
      
      .snackbar {
        background: #323232;
        border-radius: 2px;
        bottom: 24px;
        box-sizing: border-box;
        color: #fff;
        font-size: .87em;
        left: 24px;
        max-width: 568px;
        min-width: 288px;
        opacity: 0;
        padding: 16px 24px 12px;
        position: fixed;
        transform: translateY(90px);
        will-change: opacity, transform;
        z-index: 999;
      }
      
      .snackbar-show {
        animation:
          show-snackbar 250ms cubic-bezier(0, 0, 0.2, 1) forwards,
          hide-snackbar 250ms cubic-bezier(0.4, 0, 1, 1) forwards 5s;
      }
      
      @keyframes show-snackbar {
        100% {
          opacity: 1;
          transform: translateY(0);
        }
      }
      
      @keyframes hide-snackbar {
        0% {
          opacity: 1;
          transform: translateY(0);
        }
        100% {
          opacity: 0;
          transform: translateY(90px);
        }
      }
      
      .suggestions {
        margin-top: 18px;
      }
      
      .suggestion-header {
        font-weight: bold;
        margin-bottom: 4px;
      }
      
      .suggestion-body {
        color: #777;
      }
      
      /* Decrease padding at low sizes. */
      @media (max-width: 640px), (max-height: 640px) {
        h1 {
          margin: 0 0 15px;
        }
        .suggestions {
          margin-top: 10px;
        }
        .suggestion-header {
          margin-bottom: 0;
        }
      }
      
      #download-link,
      #download-link-clicked {
        margin-bottom: 30px;
        margin-top: 30px;
      }
      
      #download-link-clicked {
        color: #BBB;
      }
      
      #download-link::before,
      #download-link-clicked::before {
        content: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxLjJlbSIgaGVpZ2h0PSIxLjJlbSIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNNSAyMGgxNHYtMkg1bTE0LTloLTRWM0g5djZINWw3IDcgNy03eiIgZmlsbD0iIzQyODVGNCIvPjwvc3ZnPg==);
        display: inline-block;
        margin-inline-end: 4px;
        vertical-align: -webkit-baseline-middle;
      }
      
      #download-link-clicked::before {
        opacity: 0;
        width: 0;
      }
      
      #offline-content-list-visibility-card {
        border: 1px solid white;
        border-radius: 8px;
        display: flex;
        font-size: .8em;
        justify-content: space-between;
        line-height: 1;
      }
      
      #offline-content-list.list-hidden #offline-content-list-visibility-card {
        border-color: rgb(218, 220, 224);
      }
      
      #offline-content-list-visibility-card > div {
        padding: 1em;
      }
      
      #offline-content-list-title {
        color: var(--google-gray-700);
      }
      
      #offline-content-list-show-text,
      #offline-content-list-hide-text {
        color: rgb(66, 133, 244);
      }
      
      /* Hides the "hide" text div when the offline content list is collapsed/hidden
      * and, alternatively, hides the "show" text div when the offline content list
      * is expanded/shown.
      */
      #offline-content-list.list-hidden #offline-content-list-hide-text,
      #offline-content-list:not(.list-hidden) #offline-content-list-show-text {
        display: none;
      }
      
      /* Controls the animation of the offline content list when it is expanded/shown.
      */
      #offline-content-suggestions {
        /* Max-height has to be set for the height animation to work. The chosen value
        * is a little greater than the maximum height the list will have, when all
        * suggestions have images, so that it is never clamped. This makes so that
        * when the actual height is smaller then the animation is not as smooth.
        */
        max-height: 27em;
        transition: max-height 200ms ease-in, visibility 0s 200ms,
                    opacity 200ms 200ms linear;
      }
      
      /* Controls the animation of the offline content list when it is
      * collapsed/hidden.
      */
      #offline-content-list.list-hidden #offline-content-suggestions {
        max-height: 0;
        opacity: 0;
        transition: opacity 200ms linear, visibility 0s 200ms,
                    max-height 200ms 200ms ease-out;
        visibility: hidden;
      }
      
      #offline-content-list {
        margin-inline-start: -5%;
        width: 110%;
      }
      
      /* The selectors below adjust the "overflow" of the suggestion cards contents
      * based on the same screen size based strategy used for the main frame, which
      * is applied by the `interstitial-wrapper` class. */
      @media (max-width: 420px)  {
        #offline-content-list {
          margin-inline-start: -2.5%;
          width: 105%;
        }
      }
      @media (max-width: 420px) and (orientation: portrait),
            (max-height: 560px) {
        #offline-content-list {
          margin-inline-start: -12px;
          width: calc(100% + 24px);
        }
      }
      
      .suggestion-with-image .offline-content-suggestion-thumbnail {
        flex-basis: 8.2em;
        flex-shrink: 0;
      }
      
      .suggestion-with-image .offline-content-suggestion-thumbnail > img {
        height: 100%;
        width: 100%;
      }
      
      .suggestion-with-image #offline-content-list:not(.is-rtl)
      .offline-content-suggestion-thumbnail > img {
        border-bottom-right-radius: 7px;
        border-top-right-radius: 7px;
      }
      
      .suggestion-with-image #offline-content-list.is-rtl
      .offline-content-suggestion-thumbnail > img {
        border-bottom-left-radius: 7px;
        border-top-left-radius: 7px;
      }
      
      .suggestion-with-icon .offline-content-suggestion-thumbnail {
        align-items: center;
        display: flex;
        justify-content: center;
        min-height: 4.2em;
        min-width: 4.2em;
      }
      
      .suggestion-with-icon .offline-content-suggestion-thumbnail > div {
        align-items: center;
        background-color: rgb(241, 243, 244);
        border-radius: 50%;
        display: flex;
        height: 2.3em;
        justify-content: center;
        width: 2.3em;
      }
      
      .suggestion-with-icon .offline-content-suggestion-thumbnail > div > img {
        height: 1.45em;
        width: 1.45em;
      }
      
      .offline-content-suggestion-favicon {
        height: 1em;
        margin-inline-end: 0.4em;
        width: 1.4em;
      }
      
      .offline-content-suggestion-favicon > img {
        height: 1.4em;
        width: 1.4em;
      }
      
      .no-favicon .offline-content-suggestion-favicon {
        display: none;
      }
      
      .image-video {
        content: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNMTcgMTAuNVY3YTEgMSAwIDAgMC0xLTFINGExIDEgMCAwIDAtMSAxdjEwYTEgMSAwIDAgMCAxIDFoMTJhMSAxIDAgMCAwIDEtMXYtMy41bDQgNHYtMTFsLTQgNHoiIGZpbGw9IiMzQzQwNDMiLz48L3N2Zz4=);
      }
      
      .image-music-note {
        content: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNMTIgM3Y5LjI2Yy0uNS0uMTctMS0uMjYtMS41LS4yNkM4IDEyIDYgMTQgNiAxNi41UzggMjEgMTAuNSAyMXM0LjUtMiA0LjUtNC41VjZoNFYzaC03eiIgZmlsbD0iIzNDNDA0MyIvPjwvc3ZnPg==);
      }
      
      .image-earth {
        content: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNMTIgMmM1LjUyIDAgMTAgNC40OCAxMCAxMHMtNC40OCAxMC0xMCAxMFMyIDE3LjUyIDIgMTIgNi40OCAyIDEyIDJ6TTQgMTJoNC40YzMuNDA3LjAyMiA0LjkyMiAxLjczIDQuNTQzIDUuMTI3SDkuNDg4djIuNDdhOC4wMDQgOC4wMDQgMCAwIDAgMTAuNDk4LTguMDgzQzE5LjMyNyAxMi41MDQgMTguMzMyIDEzIDE3IDEzYy0yLjEzNyAwLTMuMjA2LS45MTYtMy4yMDYtMi43NWgtMy43NDhjLS4yNzQtMi43MjguNjgzLTQuMDkyIDIuODctNC4wOTIgMC0uOTc1LjMyNy0xLjU5Ny44MTEtMS45N0E4LjAwNCA4LjAwNCAwIDAgMCA0IDEyeiIgZmlsbD0iIzNDNDA0MyIvPjwvc3ZnPg==);
      }
      
      .image-file {
        content: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNMTMgOVYzLjVMMTguNSA5TTYgMmMtMS4xMSAwLTIgLjg5LTIgMnYxNmEyIDIgMCAwIDAgMiAyaDEyYTIgMiAwIDAgMCAyLTJWOGwtNi02SDZ6IiBmaWxsPSIjM0M0MDQzIi8+PC9zdmc+);
      }
      
      .offline-content-suggestion-texts {
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        line-height: 1.3;
        padding: .9em;
        width: 100%;
      }
      
      .offline-content-suggestion-title {
        -webkit-box-orient: vertical;
        -webkit-line-clamp: 3;
        color: rgb(32, 33, 36);
        display: -webkit-box;
        font-size: 1.1em;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      
      div.offline-content-suggestion {
        align-items: stretch;
        border: 1px solid rgb(218, 220, 224);
        border-radius: 8px;
        display: flex;
        justify-content: space-between;
        margin-bottom: .8em;
      }
      
      .suggestion-with-image {
        flex-direction: row;
        height: 8.2em;
        max-height: 8.2em;
      }
      
      .suggestion-with-icon {
        flex-direction: row-reverse;
        height: 4.2em;
        max-height: 4.2em;
      }
      
      .suggestion-with-icon .offline-content-suggestion-title {
        -webkit-line-clamp: 1;
        word-break: break-all;
      }
      
      .suggestion-with-icon .offline-content-suggestion-texts {
        padding-inline-start: 0;
      }
      
      .offline-content-suggestion-attribution-freshness {
        color: rgb(95, 99, 104);
        display: flex;
        font-size: .8em;
        line-height: 1.7em;
      }
      
      .offline-content-suggestion-attribution {
        -webkit-box-orient: vertical;
        -webkit-line-clamp: 1;
        display: -webkit-box;
        flex-shrink: 1;
        margin-inline-end: 0.3em;
        overflow: hidden;
        overflow-wrap: break-word;
        text-overflow: ellipsis;
        word-break: break-all;
      }
      
      .no-attribution .offline-content-suggestion-attribution {
        display: none;
      }
      
      .offline-content-suggestion-freshness::before {
        content: '-';
        display: inline-block;
        flex-shrink: 0;
        margin-inline-end: .1em;
        margin-inline-start: .1em;
      }
      
      .no-attribution .offline-content-suggestion-freshness::before {
        display: none;
      }
      
      .offline-content-suggestion-freshness {
        flex-shrink: 0;
      }
      
      .suggestion-with-image .offline-content-suggestion-pin-spacer {
        flex-grow: 100;
        flex-shrink: 1;
      }
      
      .suggestion-with-image .offline-content-suggestion-pin {
        content: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCI+PGRlZnM+PHBhdGggaWQ9ImEiIGQ9Ik0wIDBoMjR2MjRIMFYweiIvPjwvZGVmcz48Y2xpcFBhdGggaWQ9ImIiPjx1c2UgeGxpbms6aHJlZj0iI2EiIG92ZXJmbG93PSJ2aXNpYmxlIi8+PC9jbGlwUGF0aD48cGF0aCBjbGlwLXBhdGg9InVybCgjYikiIGQ9Ik0xMiAyQzYuNSAyIDIgNi41IDIgMTJzNC41IDEwIDEwIDEwIDEwLTQuNSAxMC0xMFMxNy41IDIgMTIgMnptNSAxNkg3di0yaDEwdjJ6bS02LjctNEw3IDEwLjdsMS40LTEuNCAxLjkgMS45IDUuMy01LjNMMTcgNy4zIDEwLjMgMTR6IiBmaWxsPSIjOUFBMEE2Ii8+PC9zdmc+);
        flex-shrink: 0;
        height: 1.4em;
        margin-inline-start: .4em;
        width: 1.4em;
      }
      
      /* Controls the animation (and a bit more) of the launch-downloads-home action
      * button when the offline content list is expanded/shown.
      */
      #offline-content-list-action {
        text-align: center;
        transition: visibility 0s 200ms, opacity 200ms 200ms linear;
      }
      
      /* Controls the animation of the launch-downloads-home action button when the
      * offline content list is collapsed/hidden.
      */
      #offline-content-list.list-hidden #offline-content-list-action {
        opacity: 0;
        transition: opacity 200ms linear, visibility 0s 200ms;
        visibility: hidden;
      }
      
      #cancel-save-page-button {
        background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCIgd2lkdGg9IjI0IiBoZWlnaHQ9IjI0Ij48Y2xpcFBhdGggaWQ9Im1hc2siPjxwYXRoIGQ9Ik0xMiAyQzYuNSAyIDIgNi41IDIgMTJzNC41IDEwIDEwIDEwIDEwLTQuNSAxMC0xMFMxNy41IDIgMTIgMnptNSAxNkg3di0yaDEwdjJ6bS02LjctNEw3IDEwLjdsMS40LTEuNCAxLjkgMS45IDUuMy01LjNMMTcgNy4zIDEwLjMgMTR6IiBmaWxsPSIjOUFBMEE2Ii8+PC9jbGlwUGF0aD48cGF0aCBjbGlwLXBhdGg9InVybCgjbWFzaykiIGZpbGw9IiM5QUEwQTYiIGQ9Ik0wIDBoMjR2MjRIMHoiLz48cGF0aCBjbGlwLXBhdGg9InVybCgjbWFzaykiIGZpbGw9IiMxQTczRTgiIHN0eWxlPSJhbmltYXRpb246b2ZmbGluZUFuaW1hdGlvbiA0cyBpbmZpbml0ZSIgZD0iTTAgMGgyNHYyNEgweiIvPjxzdHlsZT5Aa2V5ZnJhbWVzIG9mZmxpbmVBbmltYXRpb257MCUsMzUle2hlaWdodDowfTYwJXtoZWlnaHQ6MTAwJX05MCV7ZmlsbC1vcGFjaXR5OjF9dG97ZmlsbC1vcGFjaXR5OjB9fTwvc3R5bGU+PC9zdmc+);
        background-position: right 27px center;
        background-repeat: no-repeat;
        border: 1px solid var(--google-gray-300);
        border-radius: 5px;
        color: var(--google-gray-700);
        margin-bottom: 26px;
        padding-bottom: 16px;
        padding-inline-end: 88px;
        padding-inline-start: 16px;
        padding-top: 16px;
        text-align: start;
      }
      
      html[dir='rtl'] #cancel-save-page-button {
        background-position: left 27px center;
      }
      
      #save-page-for-later-button {
        display: flex;
        justify-content: start;
      }
      
      #save-page-for-later-button a::before {
        content: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxLjJlbSIgaGVpZ2h0PSIxLjJlbSIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNNSAyMGgxNHYtMkg1bTE0LTloLTRWM0g5djZINWw3IDcgNy03eiIgZmlsbD0iIzQyODVGNCIvPjwvc3ZnPg==);
        display: inline-block;
        margin-inline-end: 4px;
        vertical-align: -webkit-baseline-middle;
      }
      
      .hidden#save-page-for-later-button {
        display: none;
      }
      
      /* Don't allow overflow when in a subframe. */
      html[subframe] body {
        overflow: hidden;
      }
      
      #sub-frame-error {
        align-items: center;
        flex-flow: column;
        justify-content: center;
        background-color: #DDD;
        display: -webkit-flex;
        height: 100%;
        left: 0;
        position: absolute;
        text-align: center;
        top: 0;
        transition: background-color 200ms ease-in-out;
        width: 100%;
      }
      
      #sub-frame-error:hover {
        background-color: #EEE;
      }
      
      #sub-frame-error .icon-generic {
        margin: 0 0 16px;
      }
      
      #sub-frame-error-details {
        margin: 0 10px;
        text-align: center;
        visibility: hidden;
      }
      
      /* Show details only when hovering. */
      #sub-frame-error:hover #sub-frame-error-details {
        visibility: visible;
      }
      
      /* If the iframe is too small, always hide the error code. */
      /* TODO(mmenke): See if overflow: no-display works better, once supported. */
      @media (max-width: 200px), (max-height: 95px) {
        #sub-frame-error-details {
          display: none;
        }
      }
      
      /* Adjust icon for small embedded frames in apps. */
      @media (max-height: 100px) {
        #sub-frame-error .icon-generic {
          height: auto;
          margin: 0;
          padding-top: 0;
          width: 25px;
        }
      }
      
      /* details-button is special; it's a <button> element that looks like a link. */
      #details-button {
        box-shadow: none;
        min-width: 0;
      }
      
      /* Styles for platform dependent separation of controls and details button. */
      .suggested-left > #control-buttons,
      .suggested-right > #details-button {
        float: left;
      }
      
      .suggested-right > #control-buttons,
      .suggested-left > #details-button {
        float: right;
      }
      
      .suggested-left .secondary-button {
        margin-inline-end: 0;
        margin-inline-start: 16px;
      }
      
      #details-button.singular {
        float: none;
      }
      
      /* download-button shows both icon and text. */
      #download-button {
        padding-bottom: 4px;
        padding-top: 4px;
        position: relative;
      }
      
      #download-button::before {
        background: -webkit-image-set(
            url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAQAAABKfvVzAAAAO0lEQVQ4y2NgGArgPxIY1YChsOE/LtBAmpYG0mxpIOSDBpKUo2lpIDZxNJCkHKqlYZAla3RAHQ1DFgAARRroHyLNTwwAAAAASUVORK5CYII=) 1x,
            url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAQAAAD9CzEMAAAAZElEQVRYw+3Ruw3AMAwDUY3OzZUmRRD4E9iim9wNwAdbEURHyk4AAAAATiCVK8lLyPsKeT9K3lsownnunfkPxO78hKiYHxBV8x2icr5BVM+/CMf8g3DN34Rzns6ViwHUAUQ/6wIAd5Km7l6c8AAAAABJRU5ErkJggg==) 2x)
          no-repeat;
        content: '';
        display: inline-block;
        height: 24px;
        margin-inline-end: 4px;
        margin-inline-start: -4px;
        vertical-align: middle;
        width: 24px;
      }
      
      #download-button:disabled {
        background: rgb(180, 206, 249);
        color: rgb(255, 255, 255);
      }
      
      #buttons::after {
        clear: both;
        content: '';
        display: block;
        width: 100%;
      }
      
      /* Offline page */
      html[dir='rtl'] .runner-container,
      html[dir='rtl'].offline .icon-offline {
        transform: scaleX(-1);
      }
      
      .offline {
        transition: filter 1.5s cubic-bezier(0.65, 0.05, 0.36, 1),
                    background-color 1.5s cubic-bezier(0.65, 0.05, 0.36, 1);
      
        will-change: filter, background-color;
      
      }
      
      .offline body {
        transition: background-color 1.5s cubic-bezier(0.65, 0.05, 0.36, 1);
      }
      
      .offline #main-message > p {
        display: none;
      }
      
      .offline.inverted {
        background-color: #fff;
        filter: invert(1);
      }
      
      .offline.inverted body {
        background-color: #fff;
      }
      
      .offline .interstitial-wrapper {
        color: var(--text-color);
        font-size: 1em;
        line-height: 1.55;
        margin: 0 auto;
        max-width: 600px;
        padding-top: 100px;
        position: relative;
        width: 100%;
      }
      
      .offline .runner-container {
        direction: ltr;
        height: 150px;
        max-width: 600px;
        overflow: hidden;
        position: absolute;
        top: 35px;
        width: 44px;
      }
      
      .offline .runner-container:focus {
        outline: none;
      }
      
      .offline .runner-canvas {
        height: 150px;
        max-width: 600px;
        opacity: 1;
        overflow: hidden;
        position: absolute;
        top: 0;
        z-index: 10;
      }
      
      .offline .controller {
        height: 100vh;
        left: 0;
        position: absolute;
        top: 0;
        width: 100vw;
        z-index: 9;
      }
      
      #offline-resources {
        display: none;
      }
      
      #offline-instruction {
        image-rendering: pixelated;
        left: 0;
        margin: auto;
        position: absolute;
        right: 0;
        top: 60px;
        width: fit-content;
      }
      
      .offline-runner-live-region {
        bottom: 0;
        clip-path: polygon(0 0, 0 0, 0 0);
        color: var(--background-color);
        display: block;
        font-size: xx-small;
        overflow: hidden;
        position: absolute;
        text-align: center;
        transition: color 1.5s cubic-bezier(0.65, 0.05, 0.36, 1);
        user-select: none;
      }
      
      @media (max-width: 420px) {
        #download-button {
          padding-bottom: 12px;
          padding-top: 12px;
        }
      
        .suggested-left > #control-buttons,
        .suggested-right > #control-buttons {
          float: none;
        }
      
        .snackbar {
          border-radius: 0;
          bottom: 0;
          left: 0;
          width: 100%;
        }
      }
      
      @media (max-height: 350px) {
        h1 {
          margin: 0 0 15px;
        }
      
        .icon-offline {
          margin: 0 0 10px;
        }
      
        .interstitial-wrapper {
          margin-top: 5%;
        }
      
        .nav-wrapper {
          margin-top: 30px;
        }
      }
      
      @media (min-width: 420px) and (max-width: 736px) and
            (min-height: 240px) and (max-height: 420px) and
            (orientation:landscape) {
        .interstitial-wrapper {
          margin-bottom: 100px;
        }
      }
      
      @media (max-width: 360px) and (max-height: 480px) {
        .offline .interstitial-wrapper {
          padding-top: 60px;
        }
      
        .offline .runner-container {
          top: 8px;
        }
      }
      
      @media (min-height: 240px) and (orientation: landscape) {
        .offline .interstitial-wrapper {
          margin-bottom: 90px;
        }
      
        .icon-offline {
          margin-bottom: 20px;
        }
      }
      
      @media (max-height: 320px) and (orientation: landscape) {
        .icon-offline {
          margin-bottom: 0;
        }
      
        .offline .runner-container {
          top: 10px;
        }
      }
      
      @media (max-width: 240px) {
        button {
          padding-inline-end: 12px;
          padding-inline-start: 12px;
        }
      
        .interstitial-wrapper {
          overflow: inherit;
          padding: 0 8px;
        }
      }
      
      @media (max-width: 120px) {
        button {
          width: auto;
        }
      }
      
      .arcade-mode,
      .arcade-mode .runner-container,
      .arcade-mode .runner-canvas {
        image-rendering: pixelated;
        max-width: 100%;
        overflow: hidden;
      }
      
      .arcade-mode #buttons,
      .arcade-mode #main-content {
        opacity: 0;
        overflow: hidden;
      }
      
      .arcade-mode .interstitial-wrapper {
        height: 100vh;
        max-width: 100%;
        overflow: hidden;
      }
      
      .arcade-mode .runner-container {
        left: 0;
        margin: auto;
        right: 0;
        transform-origin: top center;
        transition: transform 250ms cubic-bezier(0.4, 0, 1, 1) 400ms;
        z-index: 2;
      }
      
      @media (prefers-color-scheme: dark) {
        .icon {
          filter: invert(1);
        }
      
        .offline .runner-canvas {
          filter: invert(1);
        }
      
        .offline.inverted {
          background-color: var(--background-color);
          filter: invert(0);
        }
      
        .offline.inverted body {
          background-color: #fff;
        }
      
        .offline.inverted .offline-runner-live-region {
          color: #fff;
        }
      
        #suggestions-list a {
          color: var(--link-color);
        }
      
        #error-information-button {
          filter: invert(0.6);
        }
      }
    </style>
    <script>
      const HIDDEN_CLASS = 'hidden';
      
      // Decodes a UTF16 string that is encoded as base64.
      function decodeUTF16Base64ToString(encoded_text) {
        const data = atob(encoded_text);
        let result = '';
        for (let i = 0; i < data.length; i += 2) {
          result +=
              String.fromCharCode(data.charCodeAt(i) * 256 + data.charCodeAt(i + 1));
        }
        return result;
      }
      
      function toggleHelpBox() {
        const helpBoxOuter = document.getElementById('details');
        helpBoxOuter.classList.toggle(HIDDEN_CLASS);
        const detailsButton = document.getElementById('details-button');
        if (helpBoxOuter.classList.contains(HIDDEN_CLASS)) {
          /** @suppress {missingProperties} */
          detailsButton.innerText = detailsButton.detailsText;
        } else {
          /** @suppress {missingProperties} */
          detailsButton.innerText = detailsButton.hideDetailsText;
        }
      }
      
      // Adds an icon class to the list and removes classes previously set.
      function updateIconClass(newClass) {
        const frameSelector = '#main-frame-error';
        const iconEl = document.querySelector(frameSelector + ' .icon');
      
        if (iconEl.classList.contains(newClass)) {
          return;
        }
      
        iconEl.className = 'icon ' + newClass;
      }
      
      let primaryControlOnLeft = true;
      // clang-format off
      // 
      
      function setAutoFetchState(scheduled, can_schedule) {
        document.getElementById('cancel-save-page-button')
            .classList.toggle(HIDDEN_CLASS, !scheduled);
        document.getElementById('save-page-for-later-button')
            .classList.toggle(HIDDEN_CLASS, scheduled || !can_schedule);
      }
      
      function toggleErrorInformationPopup() {
        document.getElementById('error-information-popup-container')
            .classList.toggle(HIDDEN_CLASS);
      }
      
      function getIconForSuggestedItem(item) {
        // Note: |item.content_type| contains the enum values from
        // chrome::mojom::AvailableContentType.
        switch (item.content_type) {
          case 1:  // kVideo
            return 'image-video';
          case 2:  // kAudio
            return 'image-music-note';
          case 0:  // kPrefetchedPage
          case 3:  // kOtherPage
            return 'image-earth';
        }
        return 'image-file';
      }
      
      function getSuggestedContentDiv(item, index) {
        // Note: See AvailableContentToValue in available_offline_content_helper.cc
        // for the data contained in an |item|.
        // TODO(carlosk): Present |snippet_base64| when that content becomes
        // available.
        let thumbnail = '';
        const extraContainerClasses = [];
        // html_inline.py will try to replace src attributes with data URIs using a
        // simple regex. The following is obfuscated slightly to avoid that.
        const source = 'src';
        if (item.thumbnail_data_uri) {
          extraContainerClasses.push('suggestion-with-image');
          thumbnail = `<img ${source}="${item.thumbnail_data_uri}">`;
        } else {
          extraContainerClasses.push('suggestion-with-icon');
          const iconClass = getIconForSuggestedItem(item);
          thumbnail = `<div><img class="${iconClass}"></div>`;
        }
      
        let favicon = '';
        if (item.favicon_data_uri) {
          favicon = `<img ${source}="${item.favicon_data_uri}">`;
        } else {
          extraContainerClasses.push('no-favicon');
        }
      
        if (!item.attribution_base64) {
          extraContainerClasses.push('no-attribution');
        }
      
        return `
        <div class="offline-content-suggestion ${extraContainerClasses.join(' ')}"
          onclick="launchOfflineItem('${item.ID}', '${item.name_space}')">
            <div class="offline-content-suggestion-texts">
              <div id="offline-content-suggestion-title-${index}"
                  class="offline-content-suggestion-title">
              </div>
              <div class="offline-content-suggestion-attribution-freshness">
                <div id="offline-content-suggestion-favicon-${index}"
                    class="offline-content-suggestion-favicon">
                  ${favicon}
                </div>
                <div id="offline-content-suggestion-attribution-${index}"
                    class="offline-content-suggestion-attribution">
                </div>
                <div class="offline-content-suggestion-freshness">
                  ${item.date_modified}
                </div>
                <div class="offline-content-suggestion-pin-spacer"></div>
                <div class="offline-content-suggestion-pin"></div>
              </div>
            </div>
            <div class="offline-content-suggestion-thumbnail">
              ${thumbnail}
            </div>
        </div>`;
      }
      
      /**
       * @typedef {{
       *   ID: string,
       *   name_space: string,
       *   title_base64: string,
       *   snippet_base64: string,
       *   date_modified: string,
       *   attribution_base64: string,
       *   thumbnail_data_uri: string,
       *   favicon_data_uri: string,
       *   content_type: number,
       * }}
       */
      let AvailableOfflineContent;
      
      // Populates a list of suggested offline content.
      // Note: For security reasons all content downloaded from the web is considered
      // unsafe and must be securely handled to be presented on the dino page. Images
      // have already been safely re-encoded but textual content -- like title and
      // attribution -- must be properly handled here.
      // @param {boolean} isShown
      // @param {Array<AvailableOfflineContent>} suggestions
      function offlineContentAvailable(isShown, suggestions) {
        if (!suggestions || !loadTimeData.valueExists('offlineContentList')) {
          return;
        }
      
        const suggestionsHTML = [];
        for (let index = 0; index < suggestions.length; index++) {
          suggestionsHTML.push(getSuggestedContentDiv(suggestions[index], index));
        }
      
        document.getElementById('offline-content-suggestions').innerHTML =
            suggestionsHTML.join('\n');
      
        // Sets textual web content using |textContent| to make sure it's handled as
        // plain text.
        for (let index = 0; index < suggestions.length; index++) {
          document.getElementById(`offline-content-suggestion-title-${index}`)
              .textContent =
              decodeUTF16Base64ToString(suggestions[index].title_base64);
          document.getElementById(`offline-content-suggestion-attribution-${index}`)
              .textContent =
              decodeUTF16Base64ToString(suggestions[index].attribution_base64);
        }
      
        const contentListElement = document.getElementById('offline-content-list');
        if (document.dir === 'rtl') {
          contentListElement.classList.add('is-rtl');
        }
        contentListElement.hidden = false;
        // The list is configured as hidden by default. Show it if needed.
        if (isShown) {
          toggleOfflineContentListVisibility(false);
        }
      }
      
      // Called on document load.
      function onDocumentLoadOrUpdate() {
        const downloadButtonVisible = loadTimeData.valueExists('downloadButton') &&
            loadTimeData.getValue('downloadButton').msg;
        const detailsButton = document.getElementById('details-button');
      
        // If offline content suggestions will be visible, the usual buttons will not
        // be presented.
        const offlineContentVisible =
            loadTimeData.valueExists('suggestedOfflineContentPresentation');
        if (offlineContentVisible) {
          document.querySelector('.nav-wrapper').classList.add(HIDDEN_CLASS);
          detailsButton.classList.add(HIDDEN_CLASS);
      
          document.getElementById('download-link').hidden = !downloadButtonVisible;
          document.getElementById('download-links-wrapper')
              .classList.remove(HIDDEN_CLASS);
          document.getElementById('error-information-popup-container')
              .classList.add('use-popup-container', HIDDEN_CLASS);
          document.getElementById('error-information-button')
              .classList.remove(HIDDEN_CLASS);
        }
      
        const attemptAutoFetch = loadTimeData.valueExists('attemptAutoFetch') &&
            loadTimeData.getValue('attemptAutoFetch');
      
        const reloadButtonVisible = loadTimeData.valueExists('reloadButton') &&
            loadTimeData.getValue('reloadButton').msg;
      
        const reloadButton = document.getElementById('reload-button');
        const downloadButton = document.getElementById('download-button');
        if (reloadButton.style.display === 'none' &&
            downloadButton.style.display === 'none') {
          detailsButton.classList.add('singular');
        }
      
        // Show or hide control buttons.
        const controlButtonDiv = document.getElementById('control-buttons');
        controlButtonDiv.hidden =
            offlineContentVisible || !(reloadButtonVisible || downloadButtonVisible);
      
        const iconClass = loadTimeData.valueExists('iconClass') &&
            loadTimeData.getValue('iconClass');
      
        updateIconClass(iconClass);
      
        if (iconClass === 'icon-offline') {
          document.documentElement.classList.add('offline');
          new Runner('.interstitial-wrapper');
        }
      }
      
      function onDocumentLoad() {
        // Sets up the proper button layout for the current platform.
        const buttonsDiv = document.getElementById('buttons');
        if (primaryControlOnLeft) {
          buttonsDiv.classList.add('suggested-left');
        } else {
          buttonsDiv.classList.add('suggested-right');
        }
      
        onDocumentLoadOrUpdate();
      }
      
      onload = onDocumentLoad//document.addEventListener('DOMContentLoaded', onDocumentLoad);
      function onResize() {
        const helpOuterBox = document.querySelector('#details');
        const mainContent = document.querySelector('#main-content');
      
        const detailsHidden = helpOuterBox.classList.contains(HIDDEN_CLASS);
        const runnerContainer = document.querySelector('.runner-container');
      }
      /**
       * T-Rex runner.
       * @param {string} outerContainerId Outer containing element id.
       * @param {!Object=} opt_config
       * @constructor
       * @implements {EventListener}
       * @export
       */
      function Runner(outerContainerId, opt_config) {
        // Singleton
        if (Runner.instance_) {
          return Runner.instance_;
        }
        Runner.instance_ = this;
      
        this.outerContainerEl = document.querySelector(outerContainerId);
        this.containerEl = null;
        this.snackbarEl = null;
        // A div to intercept touch events. Only set while (playing && useTouch).
        this.touchController = null;
      
        this.config = opt_config || Object.assign(Runner.config, Runner.normalConfig);
        // Logical dimensions of the container.
        this.dimensions = Runner.defaultDimensions;
      
        this.gameType = 'original';
        Runner.spriteDefinition = Runner.spriteDefinitionByType['original'];
      
        this.altGameImageSprite = null;
        this.altGameModeActive = false;
        this.altGameModeFlashTimer = null;
        this.fadeInTimer = 0;
      
        this.canvas = null;
        this.canvasCtx = null;
      
        this.tRex = null;
      
        this.distanceMeter = null;
        this.distanceRan = 0;
      
        this.highestScore = parseInt(localStorage.getItem("dinoHighScore") || 0);
      
        this.time = 0;
        this.runningTime = 0;
        this.msPerFrame = 1000 / FPS;
        this.currentSpeed = this.config.SPEED;
      
        this.obstacles = [];
      
        this.activated = false; // Whether the easter egg has been activated.
        this.playing = false; // Whether the game is currently in play state.
        this.crashed = false;
        this.paused = false;
        this.inverted = false;
        this.invertTimer = 0;
        this.resizeTimerId_ = null;
      
        this.playCount = 0;

        // Hitboxes.
        this.showHitboxes = false;
      
        // Sound FX.
        this.audioBuffer = null;
        Runner.audioCues = false;
      
        /** @type {Object} */
        this.soundFx = {};
        this.generatedSoundFx = null;
      
        // Global web audio context for playing sounds.
        this.audioContext = null;
      
        // Images.
        this.images = {};
        this.imagesLoaded = 0;
      
        // Gamepad state.
        this.pollingGamepads = false;
        this.gamepadIndex = undefined;
        this.previousGamepad = null;

        Runner.gameType = this.gameType;
        this.loadImages();
      }
      
      /**
       * Default game width.
       * @const
       */
      const DEFAULT_WIDTH = 600;
      
      /**
       * Frames per second.
       * @const
       */
      const FPS = 60;
      
      /** @const */
      const IS_HIDPI = window.devicePixelRatio > 1;
      
      /** @const */
      const IS_RTL = document.querySelector('html').dir == 'rtl';
      
      /** @const */
      const ARCADE_MODE_URL = document.title;
      
      /** @const */
      const RESOURCE_POSTFIX = 'offline-resources-';
      
      /** @const */
      const A11Y_STRINGS = {
        ariaLabel: 'dinoGameA11yAriaLabel',
        description: 'dinoGameA11yDescription',
        gameOver: 'dinoGameA11yGameOver',
        highScore: 'dinoGameA11yHighScore',
        jump: 'dinoGameA11yJump',
        started: 'dinoGameA11yStartGame',
      };
      
      /**
       * Default game configuration.
       * Shared config for all  versions of the game. Additional parameters are
       * defined in Runner.normalConfig.
       */
      Runner.config = {
        BG_CLOUD_SPEED: 0.2,
        BOTTOM_PAD: 10,
        // Scroll Y threshold at which the game can be activated.
        CANVAS_IN_VIEW_OFFSET: 0,
        CLEAR_TIME: 0,
        CLOUD_FREQUENCY: 0.5,
        FADE_DURATION: 1,
        FLASH_DURATION: 1000,
        GAMEOVER_CLEAR_TIME: 1200,
        INITIAL_JUMP_VELOCITY: 12,
        INVERT_FADE_DURATION: 12000,
        MAX_BLINK_COUNT: 3,
        MAX_CLOUDS: 6,
        MAX_OBSTACLE_LENGTH: 3,
        MAX_OBSTACLE_DUPLICATION: 2,
        RESOURCE_TEMPLATE_ID: 'audio-resources',
        SPEED: 6,
        SPEED_DROP_COEFFICIENT: 3,
        ARCADE_MODE_INITIAL_TOP_POSITION: 35,
        ARCADE_MODE_TOP_POSITION_PERCENT: 0.1,
      };
      
      Runner.normalConfig = {
        ACCELERATION: 0.001,
        AUDIOCUE_PROXIMITY_THRESHOLD: 110,
        GAP_COEFFICIENT: 0.6,
        INVERT_DISTANCE: Infinity,
        MAX_SPEED: 13,
        SPEED: 6,
      };
      
      
      
      /**
       * Default dimensions.
       */
      Runner.defaultDimensions = {
        WIDTH: DEFAULT_WIDTH,
        HEIGHT: 150,
      };
      
      
      /**
       * CSS class names.
       * @enum {string}
       */
      Runner.classes = {
        ARCADE_MODE: 'arcade-mode',
        CANVAS: 'runner-canvas',
        CONTAINER: 'runner-container',
        CRASHED: 'crashed',
        ICON: 'icon-offline',
        INVERTED: 'inverted',
        SNACKBAR: 'snackbar',
        SNACKBAR_SHOW: 'snackbar-show',
        TOUCH_CONTROLLER: 'controller',
      };
      
      
      /**
       * Sound FX. Reference to the ID of the audio tag on interstitial page.
       * @enum {string}
       */
      Runner.sounds = {
        BUTTON_PRESS: 'offline-sound-press',
        HIT: 'offline-sound-hit',
        SCORE: 'offline-sound-reached',
      };
      
      
      /**
       * Key code mapping.
       * @enum {Object}
       */
      Runner.keycodes = {
        JUMP: {'38': 1, '32': 1, '87': 1},  // up, space, w
        DUCK: {'40': 1, '83': 1},           // down, s
        RESTART: {'13': 1},        // enter
        HITBOXES: {'72': 1},       // h
        ALT: {'65': 1},            // a
        CUES: {'67': 1},           // c
        SUPERSPEED: {'88': 1}
      };
      
      
      /**
       * Runner event names.
       * @enum {string}
       */
      Runner.events = {
        ANIM_END: 'webkitAnimationEnd',
        CLICK: 'click',
        KEYDOWN: 'keydown',
        KEYUP: 'keyup',
        POINTERDOWN: 'pointerdown',
        POINTERUP: 'pointerup',
        RESIZE: 'resize',
        TOUCHEND: 'touchend',
        TOUCHSTART: 'touchstart',
        VISIBILITY: 'visibilitychange',
        BLUR: 'blur',
        FOCUS: 'focus',
        LOAD: 'load',
        GAMEPADCONNECTED: 'gamepadconnected',
      };
      
      Runner.prototype = {
        /**
         * Toggle the alternative game type.
         */
        toggleAltGame() {
          this.tRex.setFlashing(true);
          this.altGameModeFlashTimer = this.config.FLASH_DURATION;
          this.runningTime = 0;
          this.generatedSoundFx.collect();
          // Reverse title.
          var titleArr = document.title.split("");
          var reverse = titleArr.reverse();
          var titleJoin = reverse.join("");
          document.title = titleJoin;
        },
      
        /**
         * Setting individual settings for debugging.
         * @param {string} setting
         * @param {number|string} value
         */
        updateConfigSetting(setting, value) {
          if (setting in this.config && value !== undefined) {
            this.config[setting] = value;
      
            switch (setting) {
              case 'GRAVITY':
              case 'MIN_JUMP_HEIGHT':
              case 'SPEED_DROP_COEFFICIENT':
                this.tRex.config[setting] = value;
                break;
              case 'INITIAL_JUMP_VELOCITY':
                this.tRex.setJumpVelocity(value);
                break;
              case 'SPEED':
                this.setSpeed(/** @type {number} */ (value));
                break;
            }
          }
        },
      
        /**
         * Creates an on page image element from the base 64 encoded string source.
         * @param {string} resourceName Name in data object,
         * @return {HTMLImageElement} The created element.
         */
        createImageElement(resourceName) {
          const imgSrc = loadTimeData && loadTimeData.valueExists(resourceName) ?
              loadTimeData.getString(resourceName) :
              null;
      
          if (imgSrc) {
            const el =
                /** @type {HTMLImageElement} */ (document.createElement('img'));
            el.id = resourceName;
            el.src = imgSrc;
            document.getElementById('offline-resources').appendChild(el);
            return el;
          }
          return null;
        },
      
        /**
         * Cache the appropriate image sprite from the page and get the sprite sheet
         * definition.
         */
        loadImages() {
          let scale = '1x';
          this.spriteDef = Runner.spriteDefinition.LDPI;
          if (IS_HIDPI) {
            scale = '2x';
            this.spriteDef = Runner.spriteDefinition.HDPI;
          }
      
          Runner.imageSprite = /** @type {HTMLImageElement} */
              (document.getElementById(RESOURCE_POSTFIX + scale));
      
          if (this.gameType) {
            Runner.altGameImageSprite = /** @type {HTMLImageElement} */
                (this.createImageElement('altSprites' + scale));
            Runner.altCommonImageSprite = /** @type {HTMLImageElement} */
                (this.createImageElement('altSprites' + scale));
          }
          Runner.origImageSprite = Runner.imageSprite;
      
          // Disable the alt game mode if the sprites can't be loaded.
          if (!Runner.altGameImageSprite || !Runner.altCommonImageSprite) {
            this.altGameModeActive = false;
          }
      
          if (Runner.imageSprite.complete) {
            this.init();
          } else {
            // If the images are not yet loaded, add a listener.
            Runner.imageSprite.addEventListener(Runner.events.LOAD,
                this.init.bind(this));
          }
        },
      
        /**
         * Load and decode base 64 encoded sounds.
         */
        loadSounds() {
          this.audioContext = new AudioContext();

          const resourceTemplate =
              document.getElementById(this.config.RESOURCE_TEMPLATE_ID).content;

          for (const sound in Runner.sounds) {
            let soundSrc =
                resourceTemplate.getElementById(Runner.sounds[sound]).src;
            soundSrc = soundSrc.substr(soundSrc.indexOf(',') + 1);
            const buffer = decodeBase64ToArrayBuffer(soundSrc);

            // Async, so no guarantee of order in array.
            this.audioContext.decodeAudioData(buffer, function(index, audioData) {
                this.soundFx[index] = audioData;
              }.bind(this, sound));
          }
        },
      
        /**
         * Sets the game speed. Adjust the speed accordingly if on a smaller screen.
         * @param {number=} opt_speed
         */
        setSpeed(opt_speed) {
          const speed = opt_speed || this.currentSpeed;
        },
      
        /**
         * Game initialiser.
         */
        init() {
          // Hide the static icon.
          document.querySelector('.' + Runner.classes.ICON).style.visibility =
              'hidden';
      
          this.adjustDimensions();
          this.setSpeed();
      
          const ariaLabel = getA11yString(A11Y_STRINGS.ariaLabel);
          this.containerEl = document.createElement('div');
          this.containerEl.setAttribute('role', 'application');
          this.containerEl.setAttribute('tabindex', '0');
          this.containerEl.setAttribute('title', ariaLabel);
          setTimeout((el) => el.focus(), 0, this.containerEl)
      
          this.containerEl.className = Runner.classes.CONTAINER;
      
          // Player canvas container.
          this.canvas = createCanvas(this.containerEl, this.dimensions.WIDTH,
              this.dimensions.HEIGHT);
      
          // Live region for game status updates.
          this.a11yStatusEl = document.createElement('span');
          this.a11yStatusEl.className = 'offline-runner-live-region';
          this.a11yStatusEl.setAttribute('aria-live', 'assertive');
          this.a11yStatusEl.textContent = '';
          Runner.a11yStatusEl = this.a11yStatusEl;
      
          this.containerEl.appendChild(this.a11yStatusEl);
      
          announcePhrase(getA11yString(A11Y_STRINGS.description));
      
          this.generatedSoundFx = new GeneratedSoundFx();
          this.generatedSoundFx.init();
      
          this.canvasCtx =
              /** @type {CanvasRenderingContext2D} */ (this.canvas.getContext('2d'));
          this.canvasCtx.fillStyle = '#f7f7f7';
          this.canvasCtx.fill();
          Runner.updateCanvasScaling(this.canvas);
      
          // Horizon contains clouds, obstacles and the ground.
          this.horizon = new Horizon(this.canvas, this.spriteDef, this.dimensions,
              this.config.GAP_COEFFICIENT);
      
          // Distance meter
          this.distanceMeter = new DistanceMeter(this.canvas,
                this.spriteDef.TEXT_SPRITE, this.dimensions.WIDTH);
          this.distanceMeter.setHighScore(this.highestScore);
      
          // Draw t-rex
          this.tRex = new Trex(this.canvas, this.spriteDef.TREX);
      
          this.outerContainerEl.appendChild(this.containerEl);
      
          this.startListening();
          this.update();
      
          window.addEventListener(Runner.events.RESIZE,
              this.debounceResize.bind(this));
      
          // Handle dark mode
          const darkModeMediaQuery =
              window.matchMedia('(prefers-color-scheme: dark)');
          this.isDarkMode = darkModeMediaQuery && darkModeMediaQuery.matches;
          darkModeMediaQuery.addListener((e) => {
            this.isDarkMode = e.matches;
          });
        },
      
        /**
         * Create the touch controller. A div that covers whole screen.
         */
        createTouchController() {
          this.touchController = document.createElement('div');
          this.touchController.className = Runner.classes.TOUCH_CONTROLLER;
          this.touchController.addEventListener(Runner.events.TOUCHSTART, this);
          this.touchController.addEventListener(Runner.events.TOUCHEND, this);
          this.outerContainerEl.appendChild(this.touchController);
        },
      
        /**
         * Debounce the resize event.
         */
        debounceResize() {
          if (!this.resizeTimerId_) {
            this.resizeTimerId_ =
                setInterval(this.adjustDimensions.bind(this), 250);
          }
        },
      
        /**
         * Adjust game space dimensions on resize.
         */
        adjustDimensions() {
          clearInterval(this.resizeTimerId_);
          this.resizeTimerId_ = null;
      
          const boxStyles = window.getComputedStyle(this.outerContainerEl);
          const padding = Number(boxStyles.paddingLeft.substr(0,
              boxStyles.paddingLeft.length - 2));
      
          this.dimensions.WIDTH = this.outerContainerEl.offsetWidth - padding * 2;
          if (this.isArcadeMode()) {
            this.dimensions.WIDTH = Math.min(DEFAULT_WIDTH, this.dimensions.WIDTH);
            if (this.activated) {
              this.setArcadeModeContainerScale();
            }
          }
      
          // Redraw the elements back onto the canvas.
          if (this.canvas) {
            this.canvas.width = this.dimensions.WIDTH;
            this.canvas.height = this.dimensions.HEIGHT;
      
            Runner.updateCanvasScaling(this.canvas);
      
            this.distanceMeter.calcXPos(this.dimensions.WIDTH);
            this.clearCanvas();
            this.horizon.update(0, 0, true);
            this.tRex.update(0);
      
            // Outer container and distance meter.
            if (this.playing || this.crashed || this.paused) {
              this.containerEl.style.width = this.dimensions.WIDTH + 'px';
              this.containerEl.style.height = this.dimensions.HEIGHT + 'px';
              this.distanceMeter.update(0, Math.ceil(this.distanceRan));
              this.stop();
            } else {
              this.tRex.draw(0, 0);
            }
      
            // Game over panel.
            if (this.crashed && this.gameOverPanel) {
              this.gameOverPanel.updateDimensions(this.dimensions.WIDTH);
              this.gameOverPanel.draw(this.altGameModeActive, this.tRex);
            }
          }
        },
      
        /**
         * Play the game intro.
         * Canvas container width expands out to the full width.
         */
        playIntro() {
          if (!this.activated && !this.crashed) {
            this.playingIntro = true;
            this.tRex.playingIntro = true;
      
            // CSS animation definition.
            const keyframes = '@-webkit-keyframes intro { ' +
                  'from { width:' + Trex.config.WIDTH + 'px }' +
                  'to { width: ' + this.dimensions.WIDTH + 'px }' +
                '}';
            document.styleSheets[0].insertRule(keyframes, 0);
      
            this.containerEl.addEventListener(Runner.events.ANIM_END,
                this.startGame.bind(this));
      
            this.containerEl.style.webkitAnimation = 'intro .4s ease-out 1 both';
            this.containerEl.style.width = this.dimensions.WIDTH + 'px';
      
            this.setPlayStatus(true);
            this.activated = true;
          } else if (this.crashed) {
            this.restart();
          }
        },
      
      
        /**
         * Update the game status to started.
         */
        startGame() {
          if (this.isArcadeMode()) {
            this.setArcadeMode();
          }
          this.runningTime = 0;
          this.playingIntro = false;
          this.tRex.playingIntro = false;
          this.containerEl.style.webkitAnimation = '';
          this.playCount++;
          this.generatedSoundFx.background();
          announcePhrase(getA11yString(A11Y_STRINGS.started));
      
          if (Runner.audioCues) {
            this.containerEl.setAttribute('title', getA11yString(A11Y_STRINGS.jump));
          }
      
          // Handle tabbing off the page. Pause the current game.
          document.addEventListener(Runner.events.VISIBILITY,
                this.onVisibilityChange.bind(this));
      
          window.addEventListener(Runner.events.BLUR,
                this.onVisibilityChange.bind(this));
      
          window.addEventListener(Runner.events.FOCUS,
                this.onVisibilityChange.bind(this));
        },
      
        clearCanvas() {
          this.canvasCtx.clearRect(0, 0, this.dimensions.WIDTH,
              this.dimensions.HEIGHT);
        },
      
        /**
         * Checks whether the canvas area is in the viewport of the browser
         * through the current scroll position.
         * @return boolean.
         */
        isCanvasInView() {
          return this.containerEl.getBoundingClientRect().top >
              Runner.config.CANVAS_IN_VIEW_OFFSET;
        },
      
        /**
         * Enable the alt game mode. Switching out the sprites.
         */
        enableAltGameMode() {
          Runner.imageSprite = Runner.altGameImageSprite;
          Runner.spriteDefinition = Runner.spriteDefinitionByType[Runner.gameType];
      
          if (IS_HIDPI) {
            this.spriteDef = Runner.spriteDefinition.HDPI;
          } else {
            this.spriteDef = Runner.spriteDefinition.LDPI;
          }
      
          this.altGameModeActive = true;
          this.tRex.enableAltGameMode(this.spriteDef.TREX);
          this.horizon.enableAltGameMode(this.spriteDef);
          this.generatedSoundFx.background();
        },
        /**
         * Disable the alt game mode. Switching out the sprites.
         */
        disableAltGameMode() {
          Runner.imageSprite = Runner.origImageSprite;
          Runner.spriteDefinition = Runner.spriteDefinitionByType[Runner.gameType];

          if (IS_HIDPI) {
            this.spriteDef = Runner.spriteDefinition.HDPI;
          } else {
            this.spriteDef = Runner.spriteDefinition.LDPI;
          }
      
          this.altGameModeActive = false;
          this.tRex.disableAltGameMode(this.spriteDef.TREX);
          this.horizon.disableAltGameMode(this.spriteDef);
          this.generatedSoundFx.background();
        },
      
        /**
         * Update the game frame and schedules the next one.
         */
        update() {
          this.updatePending = false;
      
          const now = getTimeStamp();
          let deltaTime = now - (this.time || now);
      
          // Flashing when switching game modes.
          if (this.altGameModeFlashTimer < 0 || this.altGameModeFlashTimer === 0) {
            this.altGameModeFlashTimer = null;
            this.tRex.setFlashing(false);
            if(this.altGameModeActive) {
              this.disableAltGameMode();
            } else {
              this.enableAltGameMode();
            }
          } else if (this.altGameModeFlashTimer > 0) {
            this.altGameModeFlashTimer -= deltaTime;
            this.tRex.update(deltaTime);
            deltaTime = 0;
          }
      
          this.time = now;
      
          if (this.playing) {
            this.clearCanvas();
      
            // Additional fade in - Prevents jump when switching sprites
            if (this.altGameModeActive &&
                this.fadeInTimer <= this.config.FADE_DURATION) {
              this.fadeInTimer += deltaTime / 1000;
              this.canvasCtx.globalAlpha = this.fadeInTimer;
            } else {
              this.canvasCtx.globalAlpha = 1;
            }
      
            if (this.tRex.jumping) {
              this.tRex.updateJump(deltaTime);
            }
      
            this.runningTime += deltaTime;
            const hasObstacles = this.runningTime > this.config.CLEAR_TIME;
      
            // First jump triggers the intro.
            if (this.tRex.jumpCount === 1 && !this.playingIntro) {
              this.playIntro();
            }
      
            // The horizon doesn't move until the intro is over.
            if (this.playingIntro) {
              this.horizon.update(0, this.currentSpeed, hasObstacles);
            } else if (!this.crashed) {
              deltaTime = !this.activated ? 0 : deltaTime;
              this.horizon.update(
                  deltaTime, this.currentSpeed, hasObstacles);
            }
      
            // Check for collisions and hitboxes.
            let collision = hasObstacles &&
                checkForCollision(this.horizon.obstacles[0], this.tRex, this.showHitboxes ? this.canvasCtx : null);
      
            // For a11y, audio cues.
            if (Runner.audioCues && hasObstacles) {
              if (!this.horizon.obstacles[0].jumpAlerted) {
                const threshold = Runner.config.AUDIOCUE_PROXIMITY_THRESHOLD;
                const adjProximityThreshold = threshold +
                    (threshold * Math.log10(this.currentSpeed / Runner.config.SPEED));
      
                if (this.horizon.obstacles[0].xPos < adjProximityThreshold) {
                  if(this.horizon.obstacles[0].yPos > 50) {
                    this.generatedSoundFx.jump();
                    if(this.horizon.obstacles[0].yPos > 75 || Runner.instance_.tRex.altGameModeEnabled) {
                      Runner.instance_.tRex.setDuck(false);
                      Runner.instance_.tRex.startJump(Runner.instance_.config.INITIAL_JUMP_VELOCITY);
                    } else {
                      Runner.instance_.tRex.setDuck(true);
                    }
                  }
                  this.horizon.obstacles[0].jumpAlerted = true;
                }
              }
            }
      
            if (!collision) {
              this.distanceRan += this.currentSpeed * deltaTime / this.msPerFrame;
      
              if (this.currentSpeed < this.config.MAX_SPEED) {
                this.currentSpeed += this.config.ACCELERATION;
              }
            } else {
              this.gameOver();
            }
      
            const playAchievementSound = this.distanceMeter.update(deltaTime,
                Math.ceil(this.distanceRan));
      
            if (!Runner.audioCues && playAchievementSound) {
              this.playSound(this.soundFx.SCORE);
            }
      
            // Night mode.
            if (!Runner.instance_.tRex.altGameModeEnabled) {
              if (this.invertTimer > this.config.INVERT_FADE_DURATION) {
                this.invertTimer = 0;
                this.invertTrigger = false;
                this.invert(false);
              } else if (this.invertTimer) {
                this.invertTimer += deltaTime;
              } else {
                const actualDistance =
                    this.distanceMeter.getActualDistance(Math.ceil(this.distanceRan));
      
                if (actualDistance > 0) {
                  this.invertTrigger =
                      !(actualDistance % this.config.INVERT_DISTANCE);
      
                  if (this.invertTrigger && this.invertTimer === 0) {
                    this.invertTimer += deltaTime;
                    this.invert(false);
                  }
                }
              }
            }
          }
      
          if (this.playing || (!this.activated &&
              this.tRex.blinkCount < Runner.config.MAX_BLINK_COUNT)) {
            this.tRex.update(deltaTime);
            this.scheduleNextUpdate();
          }
        },
      
        /**
         * Event handler.
         * @param {Event} e
         */
        handleEvent(e) {
          return (function(evtType, events) {
            switch (evtType) {
              case events.KEYDOWN:
              case events.TOUCHSTART:
              case events.POINTERDOWN:
                this.onKeyDown(e);
                break;
              case events.KEYUP:
              case events.TOUCHEND:
              case events.POINTERUP:
                this.onKeyUp(e);
                break;
              case events.GAMEPADCONNECTED:
                this.onGamepadConnected(e);
                break;
            }
          }.bind(this))(e.type, Runner.events);
        },
      
        /**
         * Initialize audio cues if activated by focus on the canvas element.
         * @param {Event} e
         */
        handleCanvasKeyPress(e) {
          if (!this.activated && !Runner.audioCues) {
            Runner.audioCues = true;
            this.generatedSoundFx.init();
            Runner.generatedSoundFx = this.generatedSoundFx;
            Runner.config.CLEAR_TIME *= 1.2;
          } else if (e.keyCode && Runner.keycodes.JUMP[e.keyCode]) {
            this.onKeyDown(e);
          }
        },
      
        /**
         * Prevent space key press from scrolling.
         * @param {Event} e
         */
        preventScrolling(e) {
          if (e.keyCode === 32) {
            e.preventDefault();
          }
        },
      
        /**
         * Bind relevant key / mouse / touch listeners.
         */
        startListening() {
          // A11y keyboard / screen reader activation.
          /*this.containerEl.addEventListener(
              Runner.events.KEYDOWN, this.handleCanvasKeyPress.bind(this));*/
          this.canvas.addEventListener(
              Runner.events.KEYDOWN, this.preventScrolling.bind(this));
          this.canvas.addEventListener(
              Runner.events.KEYUP, this.preventScrolling.bind(this));
      
          // Keys.
          document.addEventListener(Runner.events.KEYDOWN, this);
          document.addEventListener(Runner.events.KEYUP, this);
      
          // Touch / pointer.
          this.containerEl.addEventListener(Runner.events.TOUCHSTART, this, {passive: true});
          document.addEventListener(Runner.events.POINTERDOWN, this);
          document.addEventListener(Runner.events.POINTERUP, this);
      
          if (this.isArcadeMode()) {
            // Gamepad
            window.addEventListener(Runner.events.GAMEPADCONNECTED, this);
          }
        },
      
        /**
         * Remove all listeners.
         */
        stopListening() {
          document.removeEventListener(Runner.events.KEYDOWN, this);
          document.removeEventListener(Runner.events.KEYUP, this);
      
          if (this.touchController) {
            this.touchController.removeEventListener(Runner.events.TOUCHSTART, this);
            this.touchController.removeEventListener(Runner.events.TOUCHEND, this);
          }
      
          this.containerEl.removeEventListener(Runner.events.TOUCHSTART, this);
          document.removeEventListener(Runner.events.POINTERDOWN, this);
          document.removeEventListener(Runner.events.POINTERUP, this);
      
          if (this.isArcadeMode()) {
            window.removeEventListener(Runner.events.GAMEPADCONNECTED, this);
          }
        },
      
        /**
         * Process keydown.
         * @param {Event} e
         */
        onKeyDown(e) {
          if (this.isCanvasInView()) {
      
            if (!this.crashed && !this.paused) {
              if(Runner.keycodes.HITBOXES[e.keyCode]) {
                // Toggle hitboxes.
                this.showHitboxes = !this.showHitboxes;
              }
              if(Runner.keycodes.ALT[e.keyCode]) {
                // Toggle alternative game mode.
                this.toggleAltGame();
              }
              if(Runner.keycodes.CUES[e.keyCode]) {
                // Toggle jump cue.
                Runner.audioCues = !Runner.audioCues;
              }
              if(Runner.keycodes.SUPERSPEED[e.keyCode]) {
                if(Runner.instance_.isSuperspeed) {
                    Runner.instance_.currentSpeed = 10;
                    Runner.instance_.setSpeed(10);
                    Runner.instance_.tRex.setJumpVelocity(10);
                    Runner.instance_.gameOver = Runner.instance_.originalGameOver;
                    Runner.instance_.isSuperspeed = false;
                } else {
                    Runner.instance_.originalGameOver = Runner.instance_.gameOver;
                    Runner.instance_.gameOver = function() {};
                    Runner.instance_.currentSpeed = 100;
                    Runner.instance_.setSpeed(100);
                    Runner.instance_.tRex.setJumpVelocity(100);
                    Runner.instance_.isSuperspeed = true;
                }
              }
      
              if (Runner.keycodes.JUMP[e.keyCode] ||
                  e.type === Runner.events.TOUCHSTART ||
                  (Runner.keycodes.DUCK[e.keyCode] && this.altGameModeActive)) {
                e.preventDefault();
                // Starting the game for the first time.
                if (!this.playing) {
                  // Started by touch so create a touch controller.
                  if (!this.touchController && e.type === Runner.events.TOUCHSTART) {
                    this.createTouchController();
                  }
      
                  this.loadSounds();
                  this.setPlayStatus(true);
                  this.update();
                }
                // Start jump.
                if (!this.tRex.jumping && !this.tRex.ducking) {
                  if (!Runner.audioCues) {
                    this.playSound(this.soundFx.BUTTON_PRESS);
                  }
                  this.tRex.startJump(this.currentSpeed);
                }
                // Ducking is disabled on alt game modes.
              } else if (
                  !this.altGameModeActive && this.playing &&
                  Runner.keycodes.DUCK[e.keyCode]) {
                e.preventDefault();
                if (this.tRex.jumping) {
                  // Speed drop, activated only when jump key is not pressed.
                  this.tRex.setSpeedDrop();
                } else if (!this.tRex.jumping && !this.tRex.ducking) {
                  // Duck.
                  this.tRex.setDuck(true);
                }
              }
            }
          }
        },
      
        /**
         * Process key up.
         * @param {Event} e
         */
        onKeyUp(e) {
          const keyCode = String(e.keyCode);
          const isjumpKey = Runner.keycodes.JUMP[keyCode] ||
              e.type === Runner.events.TOUCHEND || e.type === Runner.events.POINTERUP;
      
          if (this.isRunning() && isjumpKey) {
            this.tRex.endJump();
          } else if (Runner.keycodes.DUCK[keyCode]) {
            this.tRex.speedDrop = false;
            this.tRex.setDuck(false);
          } else if (this.crashed) {
            // Check that enough time has elapsed before allowing jump key to restart.
            const deltaTime = getTimeStamp() - this.time;
      
            if (this.isCanvasInView() &&
                (Runner.keycodes.RESTART[keyCode] || this.isLeftClickOnCanvas(e) ||
                (deltaTime >= this.config.GAMEOVER_CLEAR_TIME &&
                Runner.keycodes.JUMP[keyCode]))) {
              this.handleGameOverClicks(e);
            }
          } else if (this.paused && isjumpKey) {
            // Reset the jump state
            this.tRex.reset();
            this.play();
          }
        },
      
        /**
         * Process gamepad connected event.
         * @param {Event} e
         */
        onGamepadConnected(e) {
          if (!this.pollingGamepads) {
            this.pollGamepadState();
          }
        },
      
        /**
         * rAF loop for gamepad polling.
         */
        pollGamepadState() {
          const gamepads = navigator.getGamepads();
          this.pollActiveGamepad(gamepads);
      
          this.pollingGamepads = true;
          requestAnimationFrame(this.pollGamepadState.bind(this));
        },
      
        /**
         * Polls for a gamepad with the jump button pressed. If one is found this
         * becomes the "active" gamepad and all others are ignored.
         * @param {!Array<Gamepad>} gamepads
         */
        pollForActiveGamepad(gamepads) {
          for (let i = 0; i < gamepads.length; ++i) {
            if (gamepads[i] && gamepads[i].buttons.length > 0 &&
                gamepads[i].buttons[0].pressed) {
              this.gamepadIndex = i;
              this.pollActiveGamepad(gamepads);
              return;
            }
          }
        },
      
        /**
         * Polls the chosen gamepad for button presses and generates KeyboardEvents
         * to integrate with the rest of the game logic.
         * @param {!Array<Gamepad>} gamepads
         */
        pollActiveGamepad(gamepads) {
          if (this.gamepadIndex === undefined) {
            this.pollForActiveGamepad(gamepads);
            return;
          }
      
          const gamepad = gamepads[this.gamepadIndex];
          if (!gamepad) {
            this.gamepadIndex = undefined;
            this.pollForActiveGamepad(gamepads);
            return;
          }
      
          // The gamepad specification defines the typical mapping of physical buttons
          // to button indicies: https://w3c.github.io/gamepad/#remapping
          this.pollGamepadButton(gamepad, 0, 38);  // Jump
          if (gamepad.buttons.length >= 2) {
            this.pollGamepadButton(gamepad, 1, 40);  // Duck
          }
          if (gamepad.buttons.length >= 10) {
            this.pollGamepadButton(gamepad, 9, 13);  // Restart
          }
      
          this.previousGamepad = gamepad;
        },
      
        /**
         * Generates a key event based on a gamepad button.
         * @param {!Gamepad} gamepad
         * @param {number} buttonIndex
         * @param {number} keyCode
         */
        pollGamepadButton(gamepad, buttonIndex, keyCode) {
          const state = gamepad.buttons[buttonIndex].pressed;
          let previousState = false;
          if (this.previousGamepad) {
            previousState = this.previousGamepad.buttons[buttonIndex].pressed;
          }
          // Generate key events on the rising and falling edge of a button press.
          if (state !== previousState) {
            const e = new KeyboardEvent(state ? Runner.events.KEYDOWN
                                            : Runner.events.KEYUP,
                                      { keyCode: keyCode });
            document.dispatchEvent(e);
          }
        },
      
        /**
         * Handle interactions on the game over screen state.
         * A user is able to tap the high score twice to reset it.
         * @param {Event} e
         */
        handleGameOverClicks(e) {
          e.preventDefault();
          if (this.distanceMeter.hasClickedOnHighScore(e) && this.highestScore) {
            if (this.distanceMeter.isHighScoreFlashing()) {
              // Subsequent click, reset the high score.
              this.saveHighScore(0, true);
              this.distanceMeter.resetHighScore();
            } else {
              // First click, flash the high score.
              this.distanceMeter.startHighScoreFlashing();
            }
          } else {
            this.distanceMeter.cancelHighScoreFlashing();
            this.restart();
          }
        },
      
        /**
         * Returns whether the event was a left click on canvas.
         * On Windows right click is registered as a click.
         * @param {Event} e
         * @return {boolean}
         */
        isLeftClickOnCanvas(e) {
          return e.button != null && e.button < 2 &&
              e.type === Runner.events.POINTERUP &&
              e.target === this.canvas;
        },
      
        /**
         * RequestAnimationFrame wrapper.
         */
        scheduleNextUpdate() {
          if (!this.updatePending) {
            this.updatePending = true;
            this.raqId = requestAnimationFrame(this.update.bind(this));
          }
        },
      
        /**
         * Whether the game is running.
         * @return {boolean}
         */
        isRunning() {
          return !!this.raqId;
        },
      
        /**
         * Sets the current high score and saves to the profile if available.
         * @param {number} distanceRan Total distance ran.
         * @param {boolean=} opt_resetScore Whether to reset the score.
         */
        saveHighScore(distanceRan, opt_resetScore) {
          this.highestScore = Math.ceil(distanceRan);
          this.distanceMeter.setHighScore(this.highestScore);
      
          // Store the new high score in the profile.
          if (opt_resetScore) {
            localStorage.removeItem("dinoHighScore");
          } else {
            localStorage.setItem("dinoHighScore", this.highestScore);
          }
        },
      
        /**
         * Game over state.
         */
        gameOver() {
          this.playSound(this.soundFx.HIT);
      
          this.stop();
          this.crashed = true;
          this.distanceMeter.achievement = false;
      
          this.tRex.update(100, Trex.status.CRASHED);
      
          // Game over panel.
          const origSpriteDef = IS_HIDPI ?
              Runner.spriteDefinitionByType.original.HDPI :
              Runner.spriteDefinitionByType.original.LDPI;
    
          if (this.canvas) {
            if (Runner.instance_.tRex.altGameModeEnabled) {
              this.gameOverPanel = new GameOverPanel(
                  this.canvas, origSpriteDef.TEXT_SPRITE, origSpriteDef.RESTART,
                  this.dimensions, origSpriteDef.ALT_GAME_END,
                  this.altGameModeActive);
            } else {
              this.gameOverPanel = new GameOverPanel(
                  this.canvas, origSpriteDef.TEXT_SPRITE, origSpriteDef.RESTART,
                  this.dimensions);
            }
          }
      
          this.gameOverPanel.draw(this.altGameModeActive, this.tRex);
      
          // Update the high score.
          if (this.distanceRan > this.highestScore) {
            this.saveHighScore(this.distanceRan);
          }
      
          // Reset the time clock.
          this.time = getTimeStamp();
      
          if (Runner.audioCues) {
            announcePhrase(
                getA11yString(A11Y_STRINGS.gameOver)
                    .replace(
                        '$1',
                        this.distanceMeter.getActualDistance(this.distanceRan)
                            .toString()) +
                ' ' +
                getA11yString(A11Y_STRINGS.highScore)
                    .replace(
                        '$1',
      
                        this.distanceMeter.getActualDistance(this.highestScore)
                            .toString()));
            this.containerEl.setAttribute(
                'title', getA11yString(A11Y_STRINGS.ariaLabel));
          }
        },
      
        stop() {
          this.setPlayStatus(false);
          this.paused = true;
          cancelAnimationFrame(this.raqId);
          this.raqId = 0;
        },
      
        play() {
          if (!this.crashed) {
            this.setPlayStatus(true);
            this.paused = false;
            this.tRex.update(0, Trex.status.RUNNING);
            this.time = getTimeStamp();
            this.update();
            this.generatedSoundFx.background();
          }
        },
      
        restart() {
          if (!this.raqId) {
            this.playCount++;
            this.runningTime = 0;
            this.setPlayStatus(true);
            this.paused = false;
            this.crashed = false;
            this.distanceRan = 0;
            this.setSpeed(this.config.SPEED);
            this.time = getTimeStamp();
            this.containerEl.classList.remove(Runner.classes.CRASHED);
            this.clearCanvas();
            this.distanceMeter.reset();
            this.horizon.reset();
            this.tRex.reset();
            this.playSound(this.soundFx.BUTTON_PRESS);
            this.invert(true);
            this.flashTimer = null;
            this.update();
            this.gameOverPanel.reset();
            this.generatedSoundFx.background();
            this.containerEl.setAttribute('title', getA11yString(A11Y_STRINGS.jump));
            announcePhrase(getA11yString(A11Y_STRINGS.started));
          }
        },
      
        setPlayStatus(isPlaying) {
          if (this.touchController) {
            this.touchController.classList.toggle(HIDDEN_CLASS, !isPlaying);
          }
          this.playing = isPlaying;
        },
      
        /**
         * Whether the game should go into arcade mode.
         * @return {boolean}
         */
        isArcadeMode() {
          // In RTL languages the title is wrapped with the left to right mark
          // control characters &#x202A; and &#x202C but are invisible.
          return IS_RTL ? document.title.indexOf(ARCADE_MODE_URL) == 1 :
                          document.title === ARCADE_MODE_URL;
        },
      
        /**
         * Hides offline messaging for a fullscreen game only experience.
         */
        setArcadeMode() {
          document.body.classList.add(Runner.classes.ARCADE_MODE);
          this.setArcadeModeContainerScale();
        },
      
        /**
         * Sets the scaling for arcade mode.
         */
        setArcadeModeContainerScale() {
          const windowHeight = window.innerHeight;
          const scaleHeight = windowHeight / this.dimensions.HEIGHT;
          const scaleWidth = window.innerWidth / this.dimensions.WIDTH;
          const scale = Math.max(1, Math.min(scaleHeight, scaleWidth));
          const scaledCanvasHeight = this.dimensions.HEIGHT * scale;
          // Positions the game container at 10% of the available vertical window
          // height minus the game container height.
          const translateY = Math.ceil(Math.max(0, (windowHeight - scaledCanvasHeight -
              Runner.config.ARCADE_MODE_INITIAL_TOP_POSITION) *
              Runner.config.ARCADE_MODE_TOP_POSITION_PERCENT)) *
              window.devicePixelRatio;
      
          const cssScale = IS_RTL ? -scale + ',' + scale : scale;
          this.containerEl.style.transform =
              'scale(' + cssScale + ') translateY(' + translateY + 'px)';
        },
      
        /**
         * Pause the game if the tab is not in focus.
         */
        onVisibilityChange(e) {
          if (document.hidden || document.webkitHidden || e.type === 'blur' ||
              document.visibilityState !== 'visible') {
            this.stop();
          } else if (!this.crashed) {
            this.tRex.reset();
            this.play();
          }
        },
      
        /**
         * Play a sound.
         * @param {AudioBuffer} soundBuffer
         */
        playSound(soundBuffer) {
          if (soundBuffer) {
            const sourceNode = this.audioContext.createBufferSource();
            sourceNode.buffer = soundBuffer;
            sourceNode.connect(this.audioContext.destination);
            sourceNode.start(0);
          }
        },
      
        /**
         * Inverts the current page / canvas colors.
         * @param {boolean} reset Whether to reset colors.
         */
        invert(reset) {
          const htmlEl = document.firstElementChild;
      
          if (reset) {
            htmlEl.classList.toggle(Runner.classes.INVERTED,
                false);
            this.invertTimer = 0;
            this.inverted = false;
          } else {
            this.inverted = htmlEl.classList.toggle(
                Runner.classes.INVERTED, this.invertTrigger);
          }
        },
      };
      
      
      /**
       * Updates the canvas size taking into
       * account the backing store pixel ratio and
       * the device pixel ratio.
       *
       * See article by Paul Lewis:
       * http://www.html5rocks.com/en/tutorials/canvas/hidpi/
       *
       * @param {HTMLCanvasElement} canvas
       * @param {number=} opt_width
       * @param {number=} opt_height
       * @return {boolean} Whether the canvas was scaled.
       */
      Runner.updateCanvasScaling = function(canvas, opt_width, opt_height) {
        const context =
            /** @type {CanvasRenderingContext2D} */ (canvas.getContext('2d'));
      
        // Query the various pixel ratios
        const devicePixelRatio = Math.floor(window.devicePixelRatio) || 1;
        /** @suppress {missingProperties} */
        const backingStoreRatio =
            Math.floor(context.webkitBackingStorePixelRatio) || 1;
        const ratio = devicePixelRatio / backingStoreRatio;
      
        // Upscale the canvas if the two ratios don't match
        if (devicePixelRatio !== backingStoreRatio) {
          const oldWidth = opt_width || canvas.width;
          const oldHeight = opt_height || canvas.height;
      
          canvas.width = oldWidth * ratio;
          canvas.height = oldHeight * ratio;
      
          canvas.style.width = oldWidth + 'px';
          canvas.style.height = oldHeight + 'px';
      
          // Scale the context to counter the fact that we've manually scaled
          // our canvas element.
          context.scale(ratio, ratio);
          return true;
        } else if (devicePixelRatio === 1) {
          // Reset the canvas width / height. Fixes scaling bug when the page is
          // zoomed and the devicePixelRatio changes accordingly.
          canvas.style.width = canvas.width + 'px';
          canvas.style.height = canvas.height + 'px';
        }
        return false;
      };
      
      
      /**
       * Generated sound FX class for audio cues.
       * @constructor
       */
      function GeneratedSoundFx() {
        this.audioCues = false;
        this.context = null;
        this.panner = null;
      }
      
      GeneratedSoundFx.prototype = {
        init() {
          this.audioCues = true;
          if (!this.context) {
            this.context = window.webkitAudioContext ? new webkitAudioContext() :
                                                      new AudioContext();
            this.panner = this.context.createStereoPanner ?
                this.context.createStereoPanner() :
                null;
          }
        },
      
        /**
         * Play oscillators at certain frequency and for a certain time.
         * @param {number} frequency
         * @param {number} startTime
         * @param {number} duration
         * @param {?number=} opt_vol
         * @param {number=} opt_pan
         */
        playNote(frequency, startTime, duration, opt_vol, opt_pan) {
          const osc1 = this.context.createOscillator();
          const osc2 = this.context.createOscillator();
          const volume = this.context.createGain();
      
          // Set oscillator wave type
          osc1.type = 'triangle';
          osc2.type = 'triangle';
          volume.gain.value = 0.1;
      
          // Set up node routing
          if (this.panner) {
            this.panner.pan.value = opt_pan || 0;
            osc1.connect(volume).connect(this.panner);
            osc2.connect(volume).connect(this.panner);
            this.panner.connect(this.context.destination);
          } else {
            osc1.connect(volume);
            osc2.connect(volume);
            volume.connect(this.context.destination);
          }
      
          // Detune oscillators for chorus effect
          osc1.frequency.value = frequency + 1;
          osc2.frequency.value = frequency - 2;
      
          // Fade out
          volume.gain.setValueAtTime(opt_vol || 0.01, startTime + duration - 0.05);
          volume.gain.linearRampToValueAtTime(0.00001, startTime + duration);
      
          // Start oscillators
          osc1.start(startTime);
          osc2.start(startTime);
          // Stop oscillators
          osc1.stop(startTime + duration);
          osc2.stop(startTime + duration);
        },
      
        background() {
          if (this.audioCues) {
            const now = this.context.currentTime;
            this.playNote(493.883, now, 0.116);
            this.playNote(659.255, now + 0.116, 0.232);
          }
        },
      
        collect() {
          if (this.audioCues) {
            const now = this.context.currentTime;
            this.playNote(830.61, now, 0.116);
            this.playNote(1318.51, now + 0.116, 0.232);
          }
        },
      
        jump() {
          if (this.audioCues) {
            const now = this.context.currentTime;
            this.playNote(659.25, now, 0.116, 0.3, -0.6);
            this.playNote(880, now + 0.116, 0.232, 0.3, -0.6);
          }
        },
      };
      
      
      /**
       * Speak a phrase using Speech Synthesis API for a11y.
       * @param {string} phrase Sentence to speak.
       */
      function speakPhrase(phrase) {
        if ('speechSynthesis' in window) {
          const msg = new SpeechSynthesisUtterance(phrase);
          const voices = window.speechSynthesis.getVoices();
          msg.text = phrase;
          speechSynthesis.speak(msg);
        }
      }
      
      
      /**
       * For screen readers make an announcement to the live region.
       * @param {string} phrase Sentence to speak.
       */
      function announcePhrase(phrase) {
        if (Runner.a11yStatusEl) {
          Runner.a11yStatusEl.textContent = '';
          Runner.a11yStatusEl.textContent = phrase;
        }
      }
      
      
      /**
       * Returns a string from loadTimeData data object.
       * @param {string} stringName
       * @return {string}
       */
      function getA11yString(stringName) {
        return loadTimeData && loadTimeData.valueExists(stringName) ?
            loadTimeData.getString(stringName) :
            '';
      }
      
      
      /**
       * Get random number.
       * @param {number} min
       * @param {number} max
       */
      function getRandomNum(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
      }
      
      
      /**
       * Create canvas element.
       * @param {Element} container Element to append canvas to.
       * @param {number} width
       * @param {number} height
       * @param {string=} opt_classname
       * @return {HTMLCanvasElement}
       */
      function createCanvas(container, width, height, opt_classname) {
        const canvas =
            /** @type {!HTMLCanvasElement} */ (document.createElement('canvas'));
        canvas.className = opt_classname ? Runner.classes.CANVAS + ' ' +
            opt_classname : Runner.classes.CANVAS;
        canvas.width = width;
        canvas.height = height;
        container.appendChild(canvas);
      
        return canvas;
      }
      
      
      /**
       * Decodes the base 64 audio to ArrayBuffer used by Web Audio.
       * @param {string} base64String
       */
      function decodeBase64ToArrayBuffer(base64String) {
        const len = (base64String.length / 4) * 3;
        const str = atob(base64String);
        const arrayBuffer = new ArrayBuffer(len);
        const bytes = new Uint8Array(arrayBuffer);
      
        for (let i = 0; i < len; i++) {
          bytes[i] = str.charCodeAt(i);
        }
        return bytes.buffer;
      }
      
      
      /**
       * Return the current timestamp.
       * @return {number}
       */
      function getTimeStamp() {
        return performance.now();
      }
      
      
      //******************************************************************************
      
      
      /**
       * Game over panel.
       * @param {!HTMLCanvasElement} canvas
       * @param {Object} textImgPos
       * @param {Object} restartImgPos
       * @param {!Object} dimensions Canvas dimensions.
       * @param {Object=} opt_altGameEndImgPos
       * @param {boolean=} opt_altGameActive
       * @constructor
       */
      function GameOverPanel(
          canvas, textImgPos, restartImgPos, dimensions, opt_altGameEndImgPos,
          opt_altGameActive) {
        this.canvas = canvas;
        this.canvasCtx =
            /** @type {CanvasRenderingContext2D} */ (canvas.getContext('2d'));
        this.canvasDimensions = dimensions;
        this.textImgPos = textImgPos;
        this.restartImgPos = restartImgPos;
        this.altGameEndImgPos = opt_altGameEndImgPos;
        this.altGameModeActive = opt_altGameActive;
      
        // Retry animation.
        this.frameTimeStamp = 0;
        this.animTimer = 0;
        this.currentFrame = 0;
      
        this.gameOverRafId = null;
      
        this.flashTimer = 0;
        this.flashCounter = 0;
        this.originalText = true;
      }
      
      GameOverPanel.RESTART_ANIM_DURATION = 875;
      GameOverPanel.LOGO_PAUSE_DURATION = 875;
      GameOverPanel.FLASH_ITERATIONS = 5;
      
      /**
       * Animation frames spec.
       */
      GameOverPanel.animConfig = {
        frames: [0, 36, 72, 108, 144, 180, 216, 252],
        msPerFrame: GameOverPanel.RESTART_ANIM_DURATION / 8,
      };
      
      /**
       * Dimensions used in the panel.
       * @enum {number}
       */
      GameOverPanel.dimensions = {
        TEXT_X: 0,
        TEXT_Y: 13,
        TEXT_WIDTH: 191,
        TEXT_HEIGHT: 11,
        RESTART_WIDTH: 36,
        RESTART_HEIGHT: 32,
      };
      
      
      GameOverPanel.prototype = {
        /**
         * Update the panel dimensions.
         * @param {number} width New canvas width.
         * @param {number} opt_height Optional new canvas height.
         */
        updateDimensions(width, opt_height) {
          this.canvasDimensions.WIDTH = width;
          if (opt_height) {
            this.canvasDimensions.HEIGHT = opt_height;
          }
          this.currentFrame = GameOverPanel.animConfig.frames.length - 1;
        },
      
        drawGameOverText(dimensions, opt_useAltText) {
          const centerX = this.canvasDimensions.WIDTH / 2;
          let textSourceX = dimensions.TEXT_X;
          let textSourceY = dimensions.TEXT_Y;
          let textSourceWidth = dimensions.TEXT_WIDTH;
          let textSourceHeight = dimensions.TEXT_HEIGHT;
      
          const textTargetX = Math.round(centerX - (dimensions.TEXT_WIDTH / 2));
          const textTargetY = Math.round((this.canvasDimensions.HEIGHT - 25) / 3);
          const textTargetWidth = dimensions.TEXT_WIDTH;
          const textTargetHeight = dimensions.TEXT_HEIGHT;
      
          if (IS_HIDPI) {
            textSourceY *= 2;
            textSourceX *= 2;
            textSourceWidth *= 2;
            textSourceHeight *= 2;
          }
      
          if (!opt_useAltText) {
            textSourceX += this.textImgPos.x;
            textSourceY += this.textImgPos.y;
          }
      
          const spriteSource =
              opt_useAltText ? Runner.altCommonImageSprite : Runner.origImageSprite;
      
          this.canvasCtx.save();
      
          if (IS_RTL) {
            this.canvasCtx.translate(this.canvasDimensions.WIDTH, 0);
            this.canvasCtx.scale(-1, 1);
          }
      
          // Game over text from sprite.
          this.canvasCtx.drawImage(
              spriteSource, textSourceX, textSourceY, textSourceWidth,
              textSourceHeight, textTargetX, textTargetY, textTargetWidth,
              textTargetHeight);
      
          this.canvasCtx.restore();
        },
      
        /**
         * Draw additional adornments for alternative game types.
         */
        drawAltGameElements(tRex) {
          // Additional adornments.
          if (this.altGameModeActive && Runner.spriteDefinition.ALT_GAME_END_CONFIG) {
            const altGameEndConfig = Runner.spriteDefinition.ALT_GAME_END_CONFIG;
      
            let altGameEndSourceWidth = altGameEndConfig.WIDTH;
            let altGameEndSourceHeight = altGameEndConfig.HEIGHT;
            const altGameEndTargetX = tRex.xPos + altGameEndConfig.X_OFFSET;
            const altGameEndTargetY = tRex.yPos + altGameEndConfig.Y_OFFSET;
      
            if (IS_HIDPI) {
              altGameEndSourceWidth *= 2;
              altGameEndSourceHeight *= 2;
            }
      
            this.canvasCtx.drawImage(
                Runner.altCommonImageSprite, this.altGameEndImgPos.x,
                this.altGameEndImgPos.y, altGameEndSourceWidth,
                altGameEndSourceHeight, altGameEndTargetX, altGameEndTargetY,
                altGameEndConfig.WIDTH, altGameEndConfig.HEIGHT);
          }
        },
      
        /**
         * Draw restart button.
         */
        drawRestartButton() {
          const dimensions = GameOverPanel.dimensions;
          let framePosX = GameOverPanel.animConfig.frames[this.currentFrame];
          let restartSourceWidth = dimensions.RESTART_WIDTH;
          let restartSourceHeight = dimensions.RESTART_HEIGHT;
          const restartTargetX =
              (this.canvasDimensions.WIDTH / 2) - (dimensions.RESTART_WIDTH / 2);
          const restartTargetY = this.canvasDimensions.HEIGHT / 2;
      
          if (IS_HIDPI) {
            restartSourceWidth *= 2;
            restartSourceHeight *= 2;
            framePosX *= 2;
          }
      
          this.canvasCtx.save();
      
          if (IS_RTL) {
            this.canvasCtx.translate(this.canvasDimensions.WIDTH, 0);
            this.canvasCtx.scale(-1, 1);
          }
      
          this.canvasCtx.drawImage(
              Runner.origImageSprite, this.restartImgPos.x + framePosX,
              this.restartImgPos.y, restartSourceWidth, restartSourceHeight,
              restartTargetX, restartTargetY, dimensions.RESTART_WIDTH,
              dimensions.RESTART_HEIGHT);
          this.canvasCtx.restore();
        },
      
      
        /**
         * Draw the panel.
         * @param {boolean} opt_altGameModeActive
         * @param {!Trex} opt_tRex
         */
        draw(opt_altGameModeActive, opt_tRex) {
          if (opt_altGameModeActive) {
            this.altGameModeActive = opt_altGameModeActive;
          }
      
          this.drawGameOverText(GameOverPanel.dimensions, false);
          this.drawRestartButton();
          this.drawAltGameElements(opt_tRex);
          this.update();
        },
      
        /**
         * Update animation frames.
         */
        update() {
          const now = getTimeStamp();
          const deltaTime = now - (this.frameTimeStamp || now);
      
          this.frameTimeStamp = now;
          this.animTimer += deltaTime;
          this.flashTimer += deltaTime;
      
          // Restart Button
          if (this.currentFrame == 0 &&
              this.animTimer > GameOverPanel.LOGO_PAUSE_DURATION) {
            this.animTimer = 0;
            this.currentFrame++;
            this.drawRestartButton();
          } else if (
              this.currentFrame > 0 &&
              this.currentFrame < GameOverPanel.animConfig.frames.length) {
            if (this.animTimer >= GameOverPanel.animConfig.msPerFrame) {
              this.currentFrame++;
              this.drawRestartButton();
            }
          } else if (
              !this.altGameModeActive &&
              this.currentFrame == GameOverPanel.animConfig.frames.length) {
            this.reset();
            return;
          }
      
          // Game over text
          if (this.altGameModeActive &&
              Runner.spriteDefinitionByType.original.ALT_GAME_OVER_TEXT_CONFIG) {
            const altTextConfig =
                Runner.spriteDefinitionByType.original.ALT_GAME_OVER_TEXT_CONFIG;
      
            if (this.flashCounter < GameOverPanel.FLASH_ITERATIONS &&
                this.flashTimer > altTextConfig.FLASH_DURATION) {
              this.flashTimer = 0;
              this.originalText = !this.originalText;
      
              this.clearGameOverTextBounds();
              if (this.originalText) {
                this.drawGameOverText(GameOverPanel.dimensions, false);
                this.flashCounter++;
              } else {
                this.drawGameOverText(altTextConfig, true);
              }
            } else if (this.flashCounter >= GameOverPanel.FLASH_ITERATIONS) {
              this.reset();
              return;
            }
          }
      
          this.gameOverRafId = requestAnimationFrame(this.update.bind(this));
        },
      
        /**
         * Clear game over text.
         */
        clearGameOverTextBounds() {
          this.canvasCtx.save();
      
          this.canvasCtx.clearRect(
              Math.round(
                  this.canvasDimensions.WIDTH / 2 -
                  (GameOverPanel.dimensions.TEXT_WIDTH / 2)),
              Math.round((this.canvasDimensions.HEIGHT - 25) / 3),
              GameOverPanel.dimensions.TEXT_WIDTH,
              GameOverPanel.dimensions.TEXT_HEIGHT + 4);
          this.canvasCtx.restore();
        },
      
        reset() {
          if (this.gameOverRafId) {
            cancelAnimationFrame(this.gameOverRafId);
            this.gameOverRafId = null;
          }
          this.animTimer = 0;
          this.frameTimeStamp = 0;
          this.currentFrame = 0;
          this.flashTimer = 0;
          this.flashCounter = 0;
          this.originalText = true;
        },
      };
      
      
      //******************************************************************************
      
      /**
       * Check for a collision.
       * @param {!Obstacle} obstacle
       * @param {!Trex} tRex T-rex object.
       * @param {CanvasRenderingContext2D=} opt_canvasCtx Optional canvas context for
       *    drawing collision boxes.
       * @return {Array<CollisionBox>|undefined}
       */
      function checkForCollision(obstacle, tRex, opt_canvasCtx) {
        const obstacleBoxXPos = Runner.defaultDimensions.WIDTH + obstacle.xPos;
      
        // Adjustments are made to the bounding box as there is a 1 pixel white
        // border around the t-rex and obstacles.
        const tRexBox = new CollisionBox(
            tRex.xPos + 1,
            tRex.yPos + 1,
            tRex.config.WIDTH - 2,
            tRex.config.HEIGHT - 2);
      
        const obstacleBox = new CollisionBox(
            obstacle.xPos + 1,
            obstacle.yPos + 1,
            obstacle.typeConfig.width * obstacle.size - 2,
            obstacle.typeConfig.height - 2);
      
        // Debug outer box
        if (opt_canvasCtx) {
          drawCollisionBoxes(opt_canvasCtx, tRexBox, obstacleBox);
        }
      
        // Simple outer bounds check.
        if (boxCompare(tRexBox, obstacleBox)) {
          const collisionBoxes = obstacle.collisionBoxes;
          let tRexCollisionBoxes = [];
      
          if (Runner.instance_.tRex.altGameModeEnabled) {
            tRexCollisionBoxes = Runner.spriteDefinition.TREX.COLLISION_BOXES;
          } else {
            tRexCollisionBoxes = tRex.ducking ? Trex.collisionBoxes.DUCKING :
                                                Trex.collisionBoxes.RUNNING;
          }
      
          // Detailed axis aligned box check.
          for (let t = 0; t < tRexCollisionBoxes.length; t++) {
            for (let i = 0; i < collisionBoxes.length; i++) {
              // Adjust the box to actual positions.
              const adjTrexBox =
                  createAdjustedCollisionBox(tRexCollisionBoxes[t], tRexBox);
              const adjObstacleBox =
                  createAdjustedCollisionBox(collisionBoxes[i], obstacleBox);
              const crashed = boxCompare(adjTrexBox, adjObstacleBox);
      
              // Draw boxes for debug.
              if (opt_canvasCtx) {
                drawCollisionBoxes(opt_canvasCtx, adjTrexBox, adjObstacleBox);
              }
      
              if (crashed) {
                return [adjTrexBox, adjObstacleBox];
              }
            }
          }
        }
      }
      
      
      /**
       * Adjust the collision box.
       * @param {!CollisionBox} box The original box.
       * @param {!CollisionBox} adjustment Adjustment box.
       * @return {CollisionBox} The adjusted collision box object.
       */
      function createAdjustedCollisionBox(box, adjustment) {
        return new CollisionBox(
            box.x + adjustment.x,
            box.y + adjustment.y,
            box.width,
            box.height);
      }
      
      
      /**
       * Draw the collision boxes for debug.
       */
      function drawCollisionBoxes(canvasCtx, tRexBox, obstacleBox) {
        canvasCtx.save();
        canvasCtx.strokeStyle = '#f0f';
        canvasCtx.strokeRect(tRexBox.x, tRexBox.y, tRexBox.width, tRexBox.height);
      
        canvasCtx.strokeStyle = '#0ff';
        canvasCtx.strokeRect(obstacleBox.x, obstacleBox.y,
            obstacleBox.width, obstacleBox.height);
        canvasCtx.restore();
      }
      
      
      /**
       * Compare two collision boxes for a collision.
       * @param {CollisionBox} tRexBox
       * @param {CollisionBox} obstacleBox
       * @return {boolean} Whether the boxes intersected.
       */
      function boxCompare(tRexBox, obstacleBox) {
        let crashed = false;
        const tRexBoxX = tRexBox.x;
        const tRexBoxY = tRexBox.y;
      
        const obstacleBoxX = obstacleBox.x;
        const obstacleBoxY = obstacleBox.y;
      
        // Axis-Aligned Bounding Box method.
        if (tRexBox.x < obstacleBoxX + obstacleBox.width &&
            tRexBox.x + tRexBox.width > obstacleBoxX &&
            tRexBox.y < obstacleBox.y + obstacleBox.height &&
            tRexBox.height + tRexBox.y > obstacleBox.y) {
          crashed = true;
        }
      
        return crashed;
      }
      
      
      //******************************************************************************
      
      /**
       * Collision box object.
       * @param {number} x X position.
       * @param {number} y Y Position.
       * @param {number} w Width.
       * @param {number} h Height.
       * @constructor
       */
      function CollisionBox(x, y, w, h) {
        this.x = x;
        this.y = y;
        this.width = w;
        this.height = h;
      }
      
      
      //******************************************************************************
      
      /**
       * Obstacle.
       * @param {CanvasRenderingContext2D} canvasCtx
       * @param {ObstacleType} type
       * @param {Object} spriteImgPos Obstacle position in sprite.
       * @param {Object} dimensions
       * @param {number} gapCoefficient Mutipler in determining the gap.
       * @param {number} speed
       * @param {number=} opt_xOffset
       * @param {boolean=} opt_isAltGameMode
       * @constructor
       */
      function Obstacle(
          canvasCtx, type, spriteImgPos, dimensions, gapCoefficient, speed,
          opt_xOffset, opt_isAltGameMode) {
        this.canvasCtx = canvasCtx;
        this.spritePos = spriteImgPos;
        this.typeConfig = type;
        this.gapCoefficient = gapCoefficient;
        this.size = getRandomNum(1, Obstacle.MAX_OBSTACLE_LENGTH);
        this.dimensions = dimensions;
        this.remove = false;
        this.xPos = dimensions.WIDTH + (opt_xOffset || 0);
        this.yPos = 0;
        this.width = 0;
        this.collisionBoxes = [];
        this.gap = 0;
        this.speedOffset = 0;
        this.altGameModeActive = opt_isAltGameMode;
        this.imageSprite = this.altGameModeActive ?
            Runner.altGameImageSprite : Runner.imageSprite;
      
        // For animated obstacles.
        this.currentFrame = 0;
        this.timer = 0;
      
        this.init(speed);
      }
      
      /**
       * Coefficient for calculating the maximum gap.
       */
      Obstacle.MAX_GAP_COEFFICIENT = 1.5;
      
      /**
       * Maximum obstacle grouping count.
       */
      Obstacle.MAX_OBSTACLE_LENGTH = 3;
      
      
      Obstacle.prototype = {
        /**
         * Initialise the DOM for the obstacle.
         * @param {number} speed
         */
        init(speed) {
          this.cloneCollisionBoxes();
      
          // Only allow sizing if we're at the right speed.
          if (this.size > 1 && this.typeConfig.multipleSpeed > speed) {
            this.size = 1;
          }
      
          this.width = this.typeConfig.width * this.size;
      
          // Check if obstacle can be positioned at various heights.
          if (Array.isArray(this.typeConfig.yPos)) {
            const yPosConfig = this.typeConfig.yPos;
            this.yPos = yPosConfig[getRandomNum(0, yPosConfig.length - 1)];
          } else {
            this.yPos = this.typeConfig.yPos;
          }
      
          this.draw();
      
          // Make collision box adjustments,
          // Central box is adjusted to the size as one box.
          //      ____        ______        ________
          //    _|   |-|    _|     |-|    _|       |-|
          //   | |<->| |   | |<--->| |   | |<----->| |
          //   | | 1 | |   | |  2  | |   | |   3   | |
          //   |_|___|_|   |_|_____|_|   |_|_______|_|
          //
          if (this.size > 1) {
            this.collisionBoxes[1].width = this.width - this.collisionBoxes[0].width -
                this.collisionBoxes[2].width;
            this.collisionBoxes[2].x = this.width - this.collisionBoxes[2].width;
          }
      
          // For obstacles that go at a different speed from the horizon.
          if (this.typeConfig.speedOffset) {
            this.speedOffset = Math.random() > 0.5 ? this.typeConfig.speedOffset :
                                                    -this.typeConfig.speedOffset;
          }
      
          this.gap = this.getGap(this.gapCoefficient, speed);
      
          // Increase gap for audio cues enabled.
          if (Runner.audioCues) {
            this.gap *= 2;
          }
        },
      
        /**
         * Draw and crop based on size.
         */
        draw() {
          let sourceWidth = this.typeConfig.width;
          let sourceHeight = this.typeConfig.height;
      
          if (IS_HIDPI) {
            sourceWidth = sourceWidth * 2;
            sourceHeight = sourceHeight * 2;
          }
      
          // X position in sprite.
          let sourceX =
              (sourceWidth * this.size) * (0.5 * (this.size - 1)) + this.spritePos.x;
      
          // Animation frames.
          if (this.currentFrame > 0) {
            sourceX += sourceWidth * this.currentFrame;
          }
      
          this.canvasCtx.drawImage(
              this.imageSprite, sourceX, this.spritePos.y, sourceWidth * this.size,
              sourceHeight, this.xPos, this.yPos, this.typeConfig.width * this.size,
              this.typeConfig.height);
        },
      
        /**
         * Obstacle frame update.
         * @param {number} deltaTime
         * @param {number} speed
         */
        update(deltaTime, speed) {
          if (!this.remove) {
            if (this.typeConfig.speedOffset) {
              speed += this.speedOffset;
            }
            this.xPos -= Math.floor((speed * FPS / 1000) * deltaTime);
      
            // Update frame
            if (this.typeConfig.numFrames) {
              this.timer += deltaTime;
              if (this.timer >= this.typeConfig.frameRate) {
                this.currentFrame =
                    this.currentFrame === this.typeConfig.numFrames - 1 ?
                    0 :
                    this.currentFrame + 1;
                this.timer = 0;
              }
            }
            this.draw();
      
            if (!this.isVisible()) {
              this.remove = true;
            }
          }
        },
      
        /**
         * Calculate a random gap size.
         * - Minimum gap gets wider as speed increses
         * @param {number} gapCoefficient
         * @param {number} speed
         * @return {number} The gap size.
         */
        getGap(gapCoefficient, speed) {
          const minGap = Math.round(
              this.width * speed + this.typeConfig.minGap * gapCoefficient);
          const maxGap = Math.round(minGap * Obstacle.MAX_GAP_COEFFICIENT);
          return getRandomNum(minGap, maxGap);
        },
      
        /**
         * Check if obstacle is visible.
         * @return {boolean} Whether the obstacle is in the game area.
         */
        isVisible() {
          return this.xPos + this.width > 0;
        },
      
        /**
         * Make a copy of the collision boxes, since these will change based on
         * obstacle type and size.
         */
        cloneCollisionBoxes() {
          const collisionBoxes = this.typeConfig.collisionBoxes;
      
          for (let i = collisionBoxes.length - 1; i >= 0; i--) {
            this.collisionBoxes[i] = new CollisionBox(
                collisionBoxes[i].x, collisionBoxes[i].y, collisionBoxes[i].width,
                collisionBoxes[i].height);
          }
        },
      };
      
      
      //******************************************************************************
      /**
       * T-rex game character.
       * @param {HTMLCanvasElement} canvas
       * @param {Object} spritePos Positioning within image sprite.
       * @constructor
       */
      function Trex(canvas, spritePos) {
        this.canvas = canvas;
        this.canvasCtx =
            /** @type {CanvasRenderingContext2D} */ (canvas.getContext('2d'));
        this.spritePos = spritePos;
        this.xPos = 0;
        this.yPos = 0;
        this.xInitialPos = 0;
        // Position when on the ground.
        this.groundYPos = 0;
        this.currentFrame = 0;
        this.currentAnimFrames = [];
        this.blinkDelay = 0;
        this.blinkCount = 0;
        this.animStartTime = 0;
        this.timer = 0;
        this.msPerFrame = 1000 / FPS;
        this.config = Object.assign(Trex.config, Trex.normalJumpConfig);
        // Current status.
        this.status = Trex.status.WAITING;
        this.jumping = false;
        this.ducking = false;
        this.jumpVelocity = 0;
        this.reachedMinHeight = false;
        this.speedDrop = false;
        this.jumpCount = 0;
        this.jumpspotX = 0;
        this.altGameModeEnabled = false;
        this.flashing = false;
      
        this.init();
      }
      
      
      /**
       * T-rex player config.
       */
      Trex.config = {
        DROP_VELOCITY: -5,
        FLASH_OFF: 175,
        FLASH_ON: 100,
        HEIGHT: 47,
        HEIGHT_DUCK: 25,
        INTRO_DURATION: 1500,
        SPEED_DROP_COEFFICIENT: 3,
        SPRITE_WIDTH: 262,
        START_X_POS: 50,
        WIDTH: 44,
        WIDTH_DUCK: 59,
      };
      
      Trex.normalJumpConfig = {
        GRAVITY: 0.6,
        MAX_JUMP_HEIGHT: 30,
        MIN_JUMP_HEIGHT: 30,
        INITIAL_JUMP_VELOCITY: -10,
      };
      
      /**
       * Used in collision detection.
       * @enum {Array<CollisionBox>}
       */
      Trex.collisionBoxes = {
        DUCKING: [new CollisionBox(1, 18, 55, 25)],
        RUNNING: [
          new CollisionBox(22, 0, 17, 16),
          new CollisionBox(1, 18, 30, 9),
          new CollisionBox(10, 35, 14, 8),
          new CollisionBox(1, 24, 29, 5),
          new CollisionBox(5, 30, 21, 4),
          new CollisionBox(9, 34, 15, 4),
        ],
      };
      
      
      /**
       * Animation states.
       * @enum {string}
       */
      Trex.status = {
        CRASHED: 'CRASHED',
        DUCKING: 'DUCKING',
        JUMPING: 'JUMPING',
        RUNNING: 'RUNNING',
        WAITING: 'WAITING',
      };
      
      /**
       * Blinking coefficient.
       * @const
       */
      Trex.BLINK_TIMING = 7000;
      
      
      /**
       * Animation config for different states.
       * @enum {Object}
       */
      Trex.animFrames = {
        WAITING: {
          frames: [44, 0],
          msPerFrame: 1000 / 3,
        },
        RUNNING: {
          frames: [88, 132],
          msPerFrame: 1000 / 12,
        },
        CRASHED: {
          frames: [220],
          msPerFrame: 1000 / 60,
        },
        JUMPING: {
          frames: [0],
          msPerFrame: 1000 / 60,
        },
        DUCKING: {
          frames: [264, 323],
          msPerFrame: 1000 / 8,
        },
      };
      
      
      Trex.prototype = {
        /**
         * T-rex player initaliser.
         * Sets the t-rex to blink at random intervals.
         */
        init() {
          this.groundYPos = Runner.defaultDimensions.HEIGHT - this.config.HEIGHT -
              Runner.config.BOTTOM_PAD;
          this.yPos = this.groundYPos;
          this.minJumpHeight = this.groundYPos - this.config.MIN_JUMP_HEIGHT;
      
          this.draw(0, 0);
          this.update(0, Trex.status.WAITING);
        },
      
        /**
         * Enables the alternative game. Redefines the dino config.
         * @param {Object} spritePos New positioning within image sprite.
         */
        enableAltGameMode: function(spritePos) {
          this.altGameModeEnabled = true;
          this.spritePos = spritePos;
          const spriteDefinition = Runner.spriteDefinition['TREX'];
      
          // Update animation frames.
          Trex.animFrames.RUNNING.frames =
              [spriteDefinition.RUNNING_1.x, spriteDefinition.RUNNING_2.x];
          Trex.animFrames.CRASHED.frames = [spriteDefinition.CRASHED.x];
      
          if (typeof spriteDefinition.JUMPING.x == 'object') {
            Trex.animFrames.JUMPING.frames = spriteDefinition.JUMPING.x;
          } else {
            Trex.animFrames.JUMPING.frames = [spriteDefinition.JUMPING.x];
          }
      
          Trex.animFrames.DUCKING.frames =
              [spriteDefinition.RUNNING_1.x, spriteDefinition.RUNNING_2.x];
          
          // Update Trex config
          Trex.config.GRAVITY = spriteDefinition.GRAVITY || Trex.config.GRAVITY;
          Trex.config.HEIGHT = spriteDefinition.RUNNING_1.h,
          Trex.config.WIDTH = spriteDefinition.RUNNING_1.w;
          Trex.config.WIDTH_JUMP = spriteDefinition.JUMPING.w;

          this.config = Trex.config;
      
          // Adjust bottom horizon placement.
          this.groundYPos = Runner.defaultDimensions.HEIGHT - this.config.HEIGHT -
              Runner.spriteDefinition['BOTTOM_PAD'];
          this.yPos = this.groundYPos;
          this.reset();
        },
        /**
         * Disables the alternative game. Redefines the dino config.
         * @param {Object} spritePos New positioning within image sprite.
         */
         disableAltGameMode: function(spritePos) {
          this.altGameModeEnabled = false;
          this.spritePos = spritePos;
          const spriteDefinition = Runner.spriteDefinition['TREX'];
      
          // Update animation frames.
          Trex.animFrames.RUNNING.frames =
              [spriteDefinition.RUNNING_1.x, spriteDefinition.RUNNING_2.x];
          Trex.animFrames.CRASHED.frames = [spriteDefinition.CRASHED.x];
      
          if (typeof spriteDefinition.JUMPING.x == 'object') {
            Trex.animFrames.JUMPING.frames = spriteDefinition.JUMPING.x;
          } else {
            Trex.animFrames.JUMPING.frames = [spriteDefinition.JUMPING.x];
          }
      
          Trex.animFrames.DUCKING.frames =
              [spriteDefinition.DUCKING_1.x, spriteDefinition.DUCKING_2.x];
          
          // Update Trex config
          Trex.config.GRAVITY = spriteDefinition.GRAVITY || Trex.config.GRAVITY;
          Trex.config.HEIGHT = spriteDefinition.RUNNING_1.h,
          Trex.config.WIDTH = spriteDefinition.RUNNING_1.w;
          Trex.config.WIDTH_JUMP = spriteDefinition.JUMPING.w;

          this.config = Trex.config;
      
          // Adjust bottom horizon placement.
          this.groundYPos = Runner.defaultDimensions.HEIGHT - this.config.HEIGHT -
              Runner.spriteDefinition['BOTTOM_PAD'];
          this.yPos = this.groundYPos;
          this.reset();
        },
      
        /**
         * Setter whether dino is flashing.
         * @param {boolean} status
         */
        setFlashing: function(status) {
          this.flashing = status;
        },
      
        /**
         * Setter for the jump velocity.
         * The approriate drop velocity is also set.
         * @param {number} setting
         */
        setJumpVelocity(setting) {
          this.config.INITIAL_JUMP_VELOCITY = -setting;
          this.config.DROP_VELOCITY = -setting / 2;
        },
      
        /**
         * Set the animation status.
         * @param {!number} deltaTime
         * @param {Trex.status=} opt_status Optional status to switch to.
         */
        update(deltaTime, opt_status) {
          this.timer += deltaTime;
      
          // Update the status.
          if (opt_status) {
            this.status = opt_status;
            this.currentFrame = 0;
            this.msPerFrame = Trex.animFrames[opt_status].msPerFrame;
            this.currentAnimFrames = Trex.animFrames[opt_status].frames;
      
            if (opt_status === Trex.status.WAITING) {
              this.animStartTime = getTimeStamp();
              this.setBlinkDelay();
            }
          }
          // Game intro animation, T-rex moves in from the left.
          if (this.playingIntro && this.xPos < this.config.START_X_POS) {
            this.xPos += Math.round((this.config.START_X_POS /
                this.config.INTRO_DURATION) * deltaTime);
            this.xInitialPos = this.xPos;
          }
      
          if (this.status === Trex.status.WAITING) {
            this.blink(getTimeStamp());
          } else {
            this.draw(this.currentAnimFrames[this.currentFrame], 0);
          }
      
          // Update the frame position.
          if (!this.flashing && this.timer >= this.msPerFrame) {
            this.currentFrame = this.currentFrame ==
                this.currentAnimFrames.length - 1 ? 0 : this.currentFrame + 1;
            this.timer = 0;
          }
      
          if (!this.altGameModeEnabled) {
            // Speed drop becomes duck if the down key is still being pressed.
            if (this.speedDrop && this.yPos === this.groundYPos) {
              this.speedDrop = false;
              this.setDuck(true);
            }
          }
        },
      
        /**
         * Draw the t-rex to a particular position.
         * @param {number} x
         * @param {number} y
         */
        draw(x, y) {
          let sourceX = x;
          let sourceY = y;
          let sourceWidth = this.ducking && this.status !== Trex.status.CRASHED ?
              this.config.WIDTH_DUCK :
              this.config.WIDTH;
          let sourceHeight = this.config.HEIGHT;
          const outputHeight = sourceHeight;
      
          let jumpOffset = Runner.spriteDefinition.TREX.JUMPING.xOffset;
      
          // Width of sprite changes on jump.
          if (this.altGameModeEnabled && this.jumping &&
              this.status !== Trex.status.CRASHED) {
            sourceWidth = this.config.WIDTH_JUMP;
          }
      
          if (IS_HIDPI) {
            sourceX *= 2;
            sourceY *= 2;
            sourceWidth *= 2;
            sourceHeight *= 2;
            jumpOffset *= 2;
          }
      
          // Adjustments for sprite sheet position.
          sourceX += this.spritePos.x;
          sourceY += this.spritePos.y;
      
          // Flashing.
          if (this.flashing) {
            if (this.timer < this.config.FLASH_ON) {
              this.canvasCtx.globalAlpha = 0.5;
            } else if (this.timer > this.config.FLASH_OFF) {
              this.timer = 0;
            }
          }
      
          // Ducking.
          if (!this.altGameModeEnabled && this.ducking &&
              this.status !== Trex.status.CRASHED) {
            this.canvasCtx.drawImage(Runner.imageSprite, sourceX, sourceY,
                sourceWidth, sourceHeight,
                this.xPos, this.yPos,
                this.config.WIDTH_DUCK, outputHeight);
          } else if (
              this.altGameModeEnabled && this.jumping &&
              this.status !== Trex.status.CRASHED) {
            // Jumping with adjustments.
            this.canvasCtx.drawImage(
                Runner.imageSprite, sourceX, sourceY, sourceWidth, sourceHeight,
                this.xPos - jumpOffset, this.yPos, this.config.WIDTH_JUMP,
                outputHeight);
          } else {
            // Crashed whilst ducking. Trex is standing up so needs adjustment.
            if (this.ducking && this.status === Trex.status.CRASHED) {
              this.xPos++;
            }
            // Standing / running
            this.canvasCtx.drawImage(Runner.imageSprite, sourceX, sourceY,
                sourceWidth, sourceHeight,
                this.xPos, this.yPos,
                this.config.WIDTH, outputHeight);
          }
          this.canvasCtx.globalAlpha = 1;
        },
      
        /**
         * Sets a random time for the blink to happen.
         */
        setBlinkDelay() {
          this.blinkDelay = Math.ceil(Math.random() * Trex.BLINK_TIMING);
        },
      
        /**
         * Make t-rex blink at random intervals.
         * @param {number} time Current time in milliseconds.
         */
        blink(time) {
          const deltaTime = time - this.animStartTime;
      
          if (deltaTime >= this.blinkDelay) {
            this.draw(this.currentAnimFrames[this.currentFrame], 0);
      
            if (this.currentFrame === 1) {
              // Set new random delay to blink.
              this.setBlinkDelay();
              this.animStartTime = time;
              this.blinkCount++;
            }
          }
        },
      
        /**
         * Initialise a jump.
         * @param {number} speed
         */
        startJump(speed) {
          if (!this.jumping) {
            this.update(0, Trex.status.JUMPING);
            // Tweak the jump velocity based on the speed.
            this.jumpVelocity = this.config.INITIAL_JUMP_VELOCITY - (speed / 10);
            this.jumping = true;
            this.reachedMinHeight = false;
            this.speedDrop = false;
      
            if (this.config.INVERT_JUMP) {
              this.minJumpHeight = this.groundYPos + this.config.MIN_JUMP_HEIGHT;
            }
          }
        },
      
        /**
         * Jump is complete, falling down.
         */
        endJump() {
          if (this.reachedMinHeight &&
              this.jumpVelocity < this.config.DROP_VELOCITY) {
            this.jumpVelocity = this.config.DROP_VELOCITY;
          }
        },
      
        /**
         * Update frame for a jump.
         * @param {number} deltaTime
         */
        updateJump(deltaTime) {
          const msPerFrame = Trex.animFrames[this.status].msPerFrame;
          const framesElapsed = deltaTime / msPerFrame;
      
          // Speed drop makes Trex fall faster.
          if (this.speedDrop) {
            this.yPos += Math.round(this.jumpVelocity *
                this.config.SPEED_DROP_COEFFICIENT * framesElapsed);
          } else if (this.config.INVERT_JUMP) {
            this.yPos -= Math.round(this.jumpVelocity * framesElapsed);
          } else {
            this.yPos += Math.round(this.jumpVelocity * framesElapsed);
          }
      
          this.jumpVelocity += this.config.GRAVITY * framesElapsed;
      
          // Minimum height has been reached.
          if (this.config.INVERT_JUMP && (this.yPos > this.minJumpHeight) ||
              !this.config.INVERT_JUMP && (this.yPos < this.minJumpHeight) ||
              this.speedDrop) {
            this.reachedMinHeight = true;
          }
      
          // Reached max height.
          if (this.config.INVERT_JUMP && (this.yPos > -this.config.MAX_JUMP_HEIGHT) ||
              !this.config.INVERT_JUMP && (this.yPos < this.config.MAX_JUMP_HEIGHT) ||
              this.speedDrop) {
            this.endJump();
          }
      
          // Back down at ground level. Jump completed.
          if ((this.config.INVERT_JUMP && this.yPos) < this.groundYPos ||
              (!this.config.INVERT_JUMP && this.yPos) > this.groundYPos) {
            this.reset();
            this.jumpCount++;
          }
        },
      
        /**
         * Set the speed drop. Immediately cancels the current jump.
         */
        setSpeedDrop() {
          this.speedDrop = true;
          this.jumpVelocity = 1;
        },
      
        /**
         * @param {boolean} isDucking
         */
        setDuck(isDucking) {
          if (isDucking && this.status !== Trex.status.DUCKING) {
            this.update(0, Trex.status.DUCKING);
            this.ducking = true;
          } else if (!isDucking && this.status === Trex.status.DUCKING) {
            this.update(0, Trex.status.RUNNING);
            this.ducking = false;
          }
        },
      
        /**
         * Reset the t-rex to running at start of game.
         */
        reset() {
          this.xPos = this.xInitialPos;
          this.yPos = this.groundYPos;
          this.jumpVelocity = 0;
          this.jumping = false;
          this.ducking = false;
          this.update(0, Trex.status.RUNNING);
          this.midair = false;
          this.speedDrop = false;
          this.jumpCount = 0;
        },
      };
      
      
      //******************************************************************************
      
      /**
       * Handles displaying the distance meter.
       * @param {!HTMLCanvasElement} canvas
       * @param {Object} spritePos Image position in sprite.
       * @param {number} canvasWidth
       * @constructor
       */
      function DistanceMeter(canvas, spritePos, canvasWidth) {
        this.canvas = canvas;
        this.canvasCtx =
            /** @type {CanvasRenderingContext2D} */ (canvas.getContext('2d'));
        this.image = Runner.imageSprite;
        this.spritePos = spritePos;
        this.x = 0;
        this.y = 5;
      
        this.currentDistance = 0;
        this.maxScore = 0;
        this.highScore = '0000';
        this.container = null;
      
        this.digits = [];
        this.achievement = false;
        this.defaultString = '';
        this.flashTimer = 0;
        this.flashIterations = 0;
        this.invertTrigger = false;
        this.flashingRafId = null;
        this.highScoreBounds = {};
        this.highScoreFlashing = false;
      
        this.config = DistanceMeter.config;
        this.maxScoreUnits = this.config.MAX_DISTANCE_UNITS;
        this.canvasWidth = canvasWidth;
        this.init(canvasWidth);
      }
      
      
      /**
       * @enum {number}
       */
      DistanceMeter.dimensions = {
        WIDTH: 10,
        HEIGHT: 13,
        DEST_WIDTH: 11,
      };
      
      
      /**
       * Y positioning of the digits in the sprite sheet.
       * X position is always 0.
       * @type {Array<number>}
       */
      DistanceMeter.yPos = [0, 13, 27, 40, 53, 67, 80, 93, 107, 120];
      
      
      /**
       * Distance meter config.
       * @enum {number}
       */
      DistanceMeter.config = {
        // Number of digits.
        MAX_DISTANCE_UNITS: 4,
      
        // Distance that causes achievement animation.
        ACHIEVEMENT_DISTANCE: 1000,
      
        // Used for conversion from pixel distance to a scaled unit.
        COEFFICIENT: 0.025,
      
        // Flash duration in milliseconds.
        FLASH_DURATION: 1000 / 4,
      
        // Flash iterations for achievement animation.
        FLASH_ITERATIONS: 3,
      
        // Padding around the high score hit area.
        HIGH_SCORE_HIT_AREA_PADDING: 4,
      };
      
      
      DistanceMeter.prototype = {
        /**
         * Initialise the distance meter to '00000'.
         * @param {number} width Canvas width in px.
         */
        init(width) {
          let maxDistanceStr = '';
      
          this.calcXPos(width);
          this.maxScore = this.maxScoreUnits;
          for (let i = 0; i < this.maxScoreUnits; i++) {
            this.draw(i, 0);
            this.defaultString += '0';
            maxDistanceStr += '9';
          }
      
          this.maxScore = parseInt(maxDistanceStr, 10);
        },
      
        /**
         * Calculate the xPos in the canvas.
         * @param {number} canvasWidth
         */
        calcXPos(canvasWidth) {
          this.x = canvasWidth - (DistanceMeter.dimensions.DEST_WIDTH *
              (this.maxScoreUnits + 1));
        },
      
        /**
         * Draw a digit to canvas.
         * @param {number} digitPos Position of the digit.
         * @param {number} value Digit value 0-9.
         * @param {boolean=} opt_highScore Whether drawing the high score.
         */
        draw(digitPos, value, opt_highScore) {
          let sourceWidth = DistanceMeter.dimensions.WIDTH;
          let sourceHeight = DistanceMeter.dimensions.HEIGHT;
          let sourceX = DistanceMeter.dimensions.WIDTH * value;
          let sourceY = 0;
      
          const targetX = digitPos * DistanceMeter.dimensions.DEST_WIDTH;
          const targetY = this.y;
          const targetWidth = DistanceMeter.dimensions.WIDTH;
          const targetHeight = DistanceMeter.dimensions.HEIGHT;
      
          // For high DPI we 2x source values.
          if (IS_HIDPI) {
            sourceWidth *= 2;
            sourceHeight *= 2;
            sourceX *= 2;
          }
      
          sourceX += this.spritePos.x;
          sourceY += this.spritePos.y;
      
          this.canvasCtx.save();
      
          if (IS_RTL) {
            if (opt_highScore) {
              this.canvasCtx.translate(
                  this.canvasWidth -
                      (DistanceMeter.dimensions.WIDTH * (this.maxScoreUnits + 3)),
                  this.y);
            } else {
              this.canvasCtx.translate(
                  this.canvasWidth - DistanceMeter.dimensions.WIDTH, this.y);
            }
            this.canvasCtx.scale(-1, 1);
          } else {
            const highScoreX =
                this.x - (this.maxScoreUnits * 2) * DistanceMeter.dimensions.WIDTH;
            if (opt_highScore) {
              this.canvasCtx.translate(highScoreX, this.y);
            } else {
              this.canvasCtx.translate(this.x, this.y);
            }
          }
      
          this.canvasCtx.drawImage(
              this.image,
              sourceX,
              sourceY,
              sourceWidth,
              sourceHeight,
              targetX,
              targetY,
              targetWidth,
              targetHeight,
          );
      
          this.canvasCtx.restore();
        },
      
        /**
         * Covert pixel distance to a 'real' distance.
         * @param {number} distance Pixel distance ran.
         * @return {number} The 'real' distance ran.
         */
        getActualDistance(distance) {
          return distance ? Math.round(distance * this.config.COEFFICIENT) : 0;
        },
      
        /**
         * Update the distance meter.
         * @param {number} distance
         * @param {number} deltaTime
         * @return {boolean} Whether the acheivement sound fx should be played.
         */
        update(deltaTime, distance) {
          let paint = true;
          let playSound = false;
      
          if (!this.achievement) {
            distance = this.getActualDistance(distance);
            // Score has gone beyond the initial digit count.
            if (distance > this.maxScore && this.maxScoreUnits ==
              this.config.MAX_DISTANCE_UNITS) {
              this.maxScoreUnits++;
              this.maxScore = parseInt(this.maxScore + '9', 10);
            } else {
              this.distance = 0;
            }
      
            if (distance > 0) {
              // Achievement unlocked.
              if (distance % this.config.ACHIEVEMENT_DISTANCE === 0) {
                // Flash score and play sound.
                this.achievement = true;
                this.flashTimer = 0;
                playSound = true;
              }
      
              // Create a string representation of the distance with leading 0.
              const distanceStr = (this.defaultString +
                  distance).substr(-this.maxScoreUnits);
              this.digits = distanceStr.split('');
            } else {
              this.digits = this.defaultString.split('');
            }
          } else {
            // Control flashing of the score on reaching acheivement.
            if (this.flashIterations <= this.config.FLASH_ITERATIONS) {
              this.flashTimer += deltaTime;
      
              if (this.flashTimer < this.config.FLASH_DURATION) {
                paint = false;
              } else if (this.flashTimer > this.config.FLASH_DURATION * 2) {
                this.flashTimer = 0;
                this.flashIterations++;
              }
            } else {
              this.achievement = false;
              this.flashIterations = 0;
              this.flashTimer = 0;
            }
          }
      
          // Draw the digits if not flashing.
          if (paint) {
            for (let i = this.digits.length - 1; i >= 0; i--) {
              this.draw(i, parseInt(this.digits[i], 10));
            }
          }
      
          this.drawHighScore();
          return playSound;
        },
      
        /**
         * Draw the high score.
         */
        drawHighScore() {
          this.canvasCtx.save();
          this.canvasCtx.globalAlpha = .8;
          for (let i = this.highScore.length - 1; i >= 0; i--) {
            this.draw(i, parseInt(this.highScore[i], 10), true);
          }
          this.canvasCtx.restore();
        },
      
        /**
         * Set the highscore as a array string.
         * Position of char in the sprite: H - 10, I - 11.
         * @param {number} distance Distance ran in pixels.
         */
        setHighScore(distance) {
          distance = this.getActualDistance(distance);
          const highScoreStr = (this.defaultString +
              distance).substr(-this.maxScoreUnits);
      
          this.highScore = ['10', '11'].concat(highScoreStr.split(''));
        },
      
      
        /**
         * Whether a clicked is in the high score area.
         * @param {Event} e Event object.
         * @return {boolean} Whether the click was in the high score bounds.
         */
        hasClickedOnHighScore(e) {
          let x = 0;
          let y = 0;
      
          if (e.touches) {
            // Bounds for touch differ from pointer.
            const canvasBounds = this.canvas.getBoundingClientRect();
            x = e.touches[0].clientX - canvasBounds.left;
            y = e.touches[0].clientY - canvasBounds.top;
          } else {
            x = e.offsetX;
            y = e.offsetY;
          }
      
          this.highScoreBounds = this.getHighScoreBounds();
          return x >= this.highScoreBounds.x && x <=
              this.highScoreBounds.x + this.highScoreBounds.width &&
              y >= this.highScoreBounds.y && y <=
              this.highScoreBounds.y + this.highScoreBounds.height;
        },
      
        /**
         * Get the bounding box for the high score.
         * @return {Object} Object with x, y, width and height properties.
         */
        getHighScoreBounds() {
          return {
            x: (this.x - (this.maxScoreUnits * 2) * DistanceMeter.dimensions.WIDTH) -
                DistanceMeter.config.HIGH_SCORE_HIT_AREA_PADDING,
            y: this.y,
            width: DistanceMeter.dimensions.WIDTH * (this.highScore.length + 1) +
                DistanceMeter.config.HIGH_SCORE_HIT_AREA_PADDING,
            height: DistanceMeter.dimensions.HEIGHT +
                (DistanceMeter.config.HIGH_SCORE_HIT_AREA_PADDING * 2),
          };
        },
      
        /**
         * Animate flashing the high score to indicate ready for resetting.
         * The flashing stops following this.config.FLASH_ITERATIONS x 2 flashes.
         */
        flashHighScore() {
          const now = getTimeStamp();
          const deltaTime = now - (this.frameTimeStamp || now);
          let paint = true;
          this.frameTimeStamp = now;
      
          // Reached the max number of flashes.
          if (this.flashIterations > this.config.FLASH_ITERATIONS * 2) {
            this.cancelHighScoreFlashing();
            return;
          }
      
          this.flashTimer += deltaTime;
      
          if (this.flashTimer < this.config.FLASH_DURATION) {
            paint = false;
          } else if (this.flashTimer > this.config.FLASH_DURATION * 2) {
            this.flashTimer = 0;
            this.flashIterations++;
          }
      
          if (paint) {
            this.drawHighScore();
          } else {
            this.clearHighScoreBounds();
          }
          // Frame update.
          this.flashingRafId =
              requestAnimationFrame(this.flashHighScore.bind(this));
        },
      
        /**
         * Draw empty rectangle over high score.
         */
        clearHighScoreBounds() {
          this.canvasCtx.save();
          this.canvasCtx.fillStyle = '#fff';
          this.canvasCtx.rect(this.highScoreBounds.x, this.highScoreBounds.y,
              this.highScoreBounds.width, this.highScoreBounds.height);
          this.canvasCtx.fill();
          this.canvasCtx.restore();
        },
      
        /**
         * Starts the flashing of the high score.
         */
        startHighScoreFlashing() {
          this.highScoreFlashing = true;
          this.flashHighScore();
        },
      
        /**
         * Whether high score is flashing.
         * @return {boolean}
         */
        isHighScoreFlashing() {
          return this.highScoreFlashing;
        },
      
        /**
         * Stop flashing the high score.
         */
        cancelHighScoreFlashing() {
          if (this.flashingRafId) {
            cancelAnimationFrame(this.flashingRafId);
          }
          this.flashIterations = 0;
          this.flashTimer = 0;
          this.highScoreFlashing = false;
          this.clearHighScoreBounds();
          this.drawHighScore();
        },
      
        /**
         * Clear the high score.
         */
        resetHighScore() {
          this.setHighScore(0);
          this.cancelHighScoreFlashing();
        },
      
        /**
         * Reset the distance meter back to '00000'.
         */
        reset() {
          this.update(0, 0);
          this.achievement = false;
        },
      };
      
      
      //******************************************************************************
      
      /**
       * Cloud background item.
       * Similar to an obstacle object but without collision boxes.
       * @param {HTMLCanvasElement} canvas Canvas element.
       * @param {Object} spritePos Position of image in sprite.
       * @param {number} containerWidth
       * @constructor
       */
      function Cloud(canvas, spritePos, containerWidth) {
        this.canvas = canvas;
        this.canvasCtx =
            /** @type {CanvasRenderingContext2D} */ (this.canvas.getContext('2d'));
        this.spritePos = spritePos;
        this.containerWidth = containerWidth;
        this.xPos = containerWidth;
        this.yPos = 0;
        this.remove = false;
        this.gap =
            getRandomNum(Cloud.config.MIN_CLOUD_GAP, Cloud.config.MAX_CLOUD_GAP);
      
        this.init();
      }
      
      
      /**
       * Cloud object config.
       * @enum {number}
       */
      Cloud.config = {
        HEIGHT: 14,
        MAX_CLOUD_GAP: 400,
        MAX_SKY_LEVEL: 30,
        MIN_CLOUD_GAP: 100,
        MIN_SKY_LEVEL: 71,
        WIDTH: 46,
      };
      
      
      Cloud.prototype = {
        /**
         * Initialise the cloud. Sets the Cloud height.
         */
        init() {
          this.yPos = getRandomNum(Cloud.config.MAX_SKY_LEVEL,
              Cloud.config.MIN_SKY_LEVEL);
          this.draw();
        },
      
        /**
         * Draw the cloud.
         */
        draw() {
          this.canvasCtx.save();
          let sourceWidth = Cloud.config.WIDTH;
          let sourceHeight = Cloud.config.HEIGHT;
          const outputWidth = sourceWidth;
          const outputHeight = sourceHeight;
          if (IS_HIDPI) {
            sourceWidth = sourceWidth * 2;
            sourceHeight = sourceHeight * 2;
          }
      
          this.canvasCtx.drawImage(Runner.imageSprite, this.spritePos.x,
              this.spritePos.y,
              sourceWidth, sourceHeight,
              this.xPos, this.yPos,
              outputWidth, outputHeight);
      
          this.canvasCtx.restore();
        },
      
        /**
         * Update the cloud position.
         * @param {number} speed
         */
        update(speed) {
          if (!this.remove) {
            this.xPos -= Math.ceil(speed);
            this.draw();
      
            // Mark as removeable if no longer in the canvas.
            if (!this.isVisible()) {
              this.remove = true;
            }
          }
        },
      
        /**
         * Check if the cloud is visible on the stage.
         * @return {boolean}
         */
        isVisible() {
          return this.xPos + Cloud.config.WIDTH > 0;
        },
      };
      
      
      /**
       * Background item.
       * Similar to cloud, without random y position.
       * @param {HTMLCanvasElement} canvas Canvas element.
       * @param {Object} spritePos Position of image in sprite.
       * @param {number} containerWidth
       * @param {string} type Element type.
       * @constructor
       */
      function BackgroundEl(canvas, spritePos, containerWidth, type) {
        this.canvas = canvas;
        this.canvasCtx =
            /** @type {CanvasRenderingContext2D} */ (this.canvas.getContext('2d'));
        this.spritePos = spritePos;
        this.containerWidth = containerWidth;
        this.xPos = containerWidth;
        this.yPos = 0;
        this.remove = false;
        this.type = type;
        this.gap =
            getRandomNum(BackgroundEl.config.MIN_GAP, BackgroundEl.config.MAX_GAP);
        this.animTimer = 0;
        this.switchFrames = false;
      
        this.spriteConfig = {};
        this.init();
      }
      
      /**
       * Background element object config.
       * Real values assigned when game type changes.
       * @enum {number}
       */
      BackgroundEl.config = {
        MAX_BG_ELS: 0,
        MAX_GAP: 0,
        MIN_GAP: 0,
        POS: 0,
        SPEED: 0,
        Y_POS: 0,
        MS_PER_FRAME: 0,  // only needed when BACKGROUND_EL.FIXED is true
      };
      
      
      BackgroundEl.prototype = {
        /**
         * Initialise the element setting the y position.
         */
        init() {
          this.spriteConfig = Runner.spriteDefinition.BACKGROUND_EL[this.type];
          if (this.spriteConfig.FIXED) {
            this.xPos = this.spriteConfig.FIXED_X_POS;
          }
          this.yPos = BackgroundEl.config.Y_POS - this.spriteConfig.HEIGHT +
              this.spriteConfig.OFFSET;
          this.draw();
        },
      
        /**
         * Draw the element.
         */
        draw() {
          this.canvasCtx.save();
          let sourceWidth = this.spriteConfig.WIDTH;
          let sourceHeight = this.spriteConfig.HEIGHT;
          let sourceX = this.spriteConfig.X_POS;
          const outputWidth = sourceWidth;
          const outputHeight = sourceHeight;
      
          if (IS_HIDPI) {
            sourceWidth *= 2;
            sourceHeight *= 2;
            sourceX *= 2;
          }
      
          this.canvasCtx.drawImage(
              Runner.imageSprite, sourceX, this.spritePos.y, sourceWidth,
              sourceHeight, this.xPos, this.yPos, outputWidth, outputHeight);
      
          this.canvasCtx.restore();
        },
      
        /**
         * Update the background element position.
         * @param {number} speed
         */
        update(speed) {
          if (!this.remove) {
            if (this.spriteConfig.FIXED) {
              this.animTimer += speed;
              if (this.animTimer > BackgroundEl.config.MS_PER_FRAME) {
                this.animTimer = 0;
                this.switchFrames = !this.switchFrames;
              }
      
              if (this.spriteConfig.FIXED_Y_POS_1 &&
                  this.spriteConfig.FIXED_Y_POS_2) {
                this.yPos = this.switchFrames ? this.spriteConfig.FIXED_Y_POS_1 :
                                                this.spriteConfig.FIXED_Y_POS_2;
              }
            } else {
              // Fixed speed, regardless of actual game speed.
              this.xPos -= BackgroundEl.config.SPEED;
            }
            this.draw();
      
            // Mark as removable if no longer in the canvas.
            if (!this.isVisible()) {
              this.remove = true;
            }
          }
        },
      
        /**
         * Check if the element is visible on the stage.
         * @return {boolean}
         */
        isVisible() {
          return this.xPos + this.spriteConfig.WIDTH > 0;
        },
      };
      
      
      
      //******************************************************************************
      
      /**
       * Nightmode shows a moon and stars on the horizon.
       * @param {HTMLCanvasElement} canvas
       * @param {number} spritePos
       * @param {number} containerWidth
       * @constructor
       */
      function NightMode(canvas, spritePos, containerWidth) {
        this.spritePos = spritePos;
        this.canvas = canvas;
        this.canvasCtx =
            /** @type {CanvasRenderingContext2D} */ (canvas.getContext('2d'));
        this.xPos = containerWidth - 50;
        this.yPos = 30;
        this.currentPhase = 0;
        this.opacity = 0;
        this.containerWidth = containerWidth;
        this.stars = [];
        this.drawStars = false;
        this.placeStars();
      }
      
      /**
       * @enum {number}
       */
      NightMode.config = {
        FADE_SPEED: 0.035,
        HEIGHT: 40,
        MOON_SPEED: 0.25,
        NUM_STARS: 2,
        STAR_SIZE: 9,
        STAR_SPEED: 0.3,
        STAR_MAX_Y: 70,
        WIDTH: 20,
      };
      
      NightMode.phases = [140, 120, 100, 60, 40, 20, 0];
      
      NightMode.prototype = {
        /**
         * Update moving moon, changing phases.
         */
        update() {
          // Fade in / out.
          if (this.opacity < 1 || this.opacity === 0) {
            this.opacity += NightMode.config.FADE_SPEED;
          } else if (this.opacity > 0) {
            this.opacity -= NightMode.config.FADE_SPEED;
          }
      
          // Set moon positioning.
          if (this.opacity > 0) {
            // Update phase.
            if(this.xPos == this.containerWidth) {
              this.currentPhase++;
        
              if (this.currentPhase >= NightMode.phases.length) {
                this.currentPhase = 0;
              }
            }

            this.xPos = this.updateXPos(this.xPos, NightMode.config.MOON_SPEED);
      
            // Update stars.
            if (this.drawStars) {
              for (let i = 0; i < NightMode.config.NUM_STARS; i++) {
                this.stars[i].x =
                    this.updateXPos(this.stars[i].x, NightMode.config.STAR_SPEED);
              }
            }
            this.draw();
          } else {
            this.opacity = 0;
            this.placeStars();
          }
          this.drawStars = true;
        },
      
        updateXPos(currentPos, speed) {
          if (currentPos < -NightMode.config.WIDTH) {
            currentPos = this.containerWidth;
          } else {
            currentPos -= speed;
          }
          return currentPos;
        },
      
        draw() {
          let moonSourceWidth = this.currentPhase === 3 ? NightMode.config.WIDTH * 2 :
                                                          NightMode.config.WIDTH;
          let moonSourceHeight = NightMode.config.HEIGHT;
          let moonSourceX = this.spritePos.x + NightMode.phases[this.currentPhase];
          const moonOutputWidth = moonSourceWidth;
          let starSize = NightMode.config.STAR_SIZE;
          let starSourceX = Runner.spriteDefinitionByType.original.LDPI.STAR.x;
      
          if (IS_HIDPI) {
            moonSourceWidth *= 2;
            moonSourceHeight *= 2;
            moonSourceX = this.spritePos.x +
                (NightMode.phases[this.currentPhase] * 2);
            starSize *= 2;
            starSourceX = Runner.spriteDefinitionByType.original.HDPI.STAR.x;
          }
      
          this.canvasCtx.save();
          this.canvasCtx.globalAlpha = this.opacity;
      
          // Stars.
          if (this.drawStars) {
            for (let i = 0; i < NightMode.config.NUM_STARS; i++) {
              this.canvasCtx.drawImage(
                  Runner.origImageSprite, starSourceX, this.stars[i].sourceY,
                  starSize, starSize, Math.round(this.stars[i].x), this.stars[i].y,
                  NightMode.config.STAR_SIZE, NightMode.config.STAR_SIZE);
            }
          }
      
          // Moon.
          this.canvasCtx.drawImage(
              Runner.origImageSprite, moonSourceX, this.spritePos.y, moonSourceWidth,
              moonSourceHeight, Math.round(this.xPos), this.yPos, moonOutputWidth,
              NightMode.config.HEIGHT);
      
          this.canvasCtx.globalAlpha = 1;
          this.canvasCtx.restore();
        },
      
        // Do star placement.
        placeStars() {
          const segmentSize = Math.round(this.containerWidth /
              NightMode.config.NUM_STARS);
      
          for (let i = 0; i < NightMode.config.NUM_STARS; i++) {
            this.stars[i] = {};
            this.stars[i].x = getRandomNum(segmentSize * i, segmentSize * (i + 1));
            this.stars[i].y = getRandomNum(0, NightMode.config.STAR_MAX_Y);
      
            if (IS_HIDPI) {
              this.stars[i].sourceY =
                  Runner.spriteDefinitionByType.original.HDPI.STAR.y +
                  NightMode.config.STAR_SIZE * 2 * i;
            } else {
              this.stars[i].sourceY =
                  Runner.spriteDefinitionByType.original.LDPI.STAR.y +
                  NightMode.config.STAR_SIZE * i;
            }
          }
        },
      
        reset() {
          this.currentPhase = 0;
          this.opacity = 0;
          this.update(false);
        },
      
      };
      
      
      //******************************************************************************
      
      /**
       * Horizon Line.
       * Consists of two connecting lines. Randomly assigns a flat / bumpy horizon.
       * @param {HTMLCanvasElement} canvas
       * @param {Object} lineConfig Configuration object.
       * @constructor
       */
      function HorizonLine(canvas, lineConfig) {
        let sourceX = lineConfig.SOURCE_X;
        let sourceY = lineConfig.SOURCE_Y;
      
        if (IS_HIDPI) {
          sourceX *= 2;
          sourceY *= 2;
        }
      
        this.spritePos = {x: sourceX, y: sourceY};
        this.canvas = canvas;
        this.canvasCtx =
            /** @type {CanvasRenderingContext2D} */ (canvas.getContext('2d'));
        this.sourceDimensions = {};
        this.dimensions = lineConfig;
      
        this.sourceXPos = [this.spritePos.x, this.spritePos.x +
            this.dimensions.WIDTH];
        this.xPos = [];
        this.yPos = 0;
        this.bumpThreshold = 0.5;
      
        this.setSourceDimensions(lineConfig);
        this.draw();
      }
      
      
      /**
       * Horizon line dimensions.
       * @enum {number}
       */
      HorizonLine.dimensions = {
        WIDTH: 600,
        HEIGHT: 12,
        YPOS: 127,
      };
      
      
      HorizonLine.prototype = {
        /**
         * Set the source dimensions of the horizon line.
         */
        setSourceDimensions(newDimensions) {
          for (const dimension in newDimensions) {
            if (dimension !== 'SOURCE_X' && dimension !== 'SOURCE_Y') {
              if (IS_HIDPI) {
                if (dimension !== 'YPOS') {
                  this.sourceDimensions[dimension] = newDimensions[dimension] * 2;
                }
              } else {
                this.sourceDimensions[dimension] = newDimensions[dimension];
              }
              this.dimensions[dimension] = newDimensions[dimension];
            }
          }
      
          this.xPos = [0, newDimensions.WIDTH];
          this.yPos = newDimensions.YPOS;
        },
      
        /**
         * Return the crop x position of a type.
         */
        getRandomType() {
          return Math.random() > this.bumpThreshold ? this.dimensions.WIDTH : 0;
        },
      
        /**
         * Draw the horizon line.
         */
        draw() {
          this.canvasCtx.drawImage(Runner.imageSprite, this.sourceXPos[0],
              this.spritePos.y,
              this.sourceDimensions.WIDTH, this.sourceDimensions.HEIGHT,
              this.xPos[0], this.yPos,
              this.dimensions.WIDTH, this.dimensions.HEIGHT);
      
          this.canvasCtx.drawImage(Runner.imageSprite, this.sourceXPos[1],
              this.spritePos.y,
              this.sourceDimensions.WIDTH, this.sourceDimensions.HEIGHT,
              this.xPos[1], this.yPos,
              this.dimensions.WIDTH, this.dimensions.HEIGHT);
        },
      
        /**
         * Update the x position of an indivdual piece of the line.
         * @param {number} pos Line position.
         * @param {number} increment
         */
        updateXPos(pos, increment) {
          const line1 = pos;
          const line2 = pos === 0 ? 1 : 0;
      
          this.xPos[line1] -= increment;
          this.xPos[line2] = this.xPos[line1] + this.dimensions.WIDTH;
      
          if (this.xPos[line1] <= -this.dimensions.WIDTH) {
            this.xPos[line1] += this.dimensions.WIDTH * 2;
            this.xPos[line2] = this.xPos[line1] - this.dimensions.WIDTH;
            this.sourceXPos[line1] = this.getRandomType() + this.spritePos.x;
          }
        },
      
        /**
         * Update the horizon line.
         * @param {number} deltaTime
         * @param {number} speed
         */
        update(deltaTime, speed) {
          const increment = Math.floor(speed * (FPS / 1000) * deltaTime);
      
          if (this.xPos[0] <= 0) {
            this.updateXPos(0, increment);
          } else {
            this.updateXPos(1, increment);
          }
          this.draw();
        },
      
        /**
         * Reset horizon to the starting position.
         */
        reset() {
          this.xPos[0] = 0;
          this.xPos[1] = this.dimensions.WIDTH;
        },
      };
      
      
      //******************************************************************************
      
      /**
       * Horizon background class.
       * @param {HTMLCanvasElement} canvas
       * @param {Object} spritePos Sprite positioning.
       * @param {Object} dimensions Canvas dimensions.
       * @param {number} gapCoefficient
       * @constructor
       */
      function Horizon(canvas, spritePos, dimensions, gapCoefficient) {
        this.canvas = canvas;
        this.canvasCtx =
            /** @type {CanvasRenderingContext2D} */ (this.canvas.getContext('2d'));
        this.config = Horizon.config;
        this.dimensions = dimensions;
        this.gapCoefficient = gapCoefficient;
        this.obstacles = [];
        this.obstacleHistory = [];
        this.horizonOffsets = [0, 0];
        this.cloudFrequency = this.config.CLOUD_FREQUENCY;
        this.spritePos = spritePos;
        this.nightMode = null;
        this.altGameModeActive = false;
      
        // Cloud
        this.clouds = [];
        this.cloudSpeed = this.config.BG_CLOUD_SPEED;
      
        // Background elements
        this.backgroundEls = [];
        this.lastEl = null;
        this.backgroundSpeed = this.config.BG_CLOUD_SPEED;
      
        // Horizon
        this.horizonLine = null;
        this.horizonLines = [];
        this.init();
      }
      
      
      /**
       * Horizon config.
       * @enum {number}
       */
      Horizon.config = {
        BG_CLOUD_SPEED: 0.2,
        BUMPY_THRESHOLD: .3,
        CLOUD_FREQUENCY: .5,
        HORIZON_HEIGHT: 16,
        MAX_CLOUDS: 6,
      };
      
      
      Horizon.prototype = {
        /**
         * Initialise the horizon. Just add the line and a cloud. No obstacles.
         */
        init() {
          Obstacle.types = Runner.spriteDefinitionByType.original.OBSTACLES;
          this.addCloud();
          // Multiple Horizon lines
          for (let i = 0; i < Runner.spriteDefinition.LINES.length; i++) {
            this.horizonLines.push(
                new HorizonLine(this.canvas, Runner.spriteDefinition.LINES[i]));
          }
      
          this.nightMode = new NightMode(this.canvas, this.spritePos.MOON,
              this.dimensions.WIDTH);
        },
      
        /**
         * Update sprites to correspond to change in sprite sheet.
         * @param {number} spritePos
         */
        enableAltGameMode: function(spritePos) {
          // Clear existing horizon objects.
          this.clouds = [];
          this.backgroundEls = [];
      
          this.altGameModeActive = true;
          this.spritePos = spritePos;
      
          Obstacle.types = Runner.spriteDefinition.OBSTACLES;
      
          Obstacle.MAX_GAP_COEFFICIENT = Runner.spriteDefinition.MAX_GAP_COEFFICIENT;
          Obstacle.MAX_OBSTACLE_LENGTH = Runner.spriteDefinition.MAX_OBSTACLE_LENGTH;
      
          BackgroundEl.config = Runner.spriteDefinition.BACKGROUND_EL_CONFIG;
      
          this.horizonLines = [];
          for (let i = 0; i < Runner.spriteDefinition.LINES.length; i++) {
            this.horizonLines.push(
                new HorizonLine(this.canvas, Runner.spriteDefinition.LINES[i]));
          }
          this.reset();
        },
        /**
         * Update sprites to correspond to change in sprite sheet.
         * @param {number} spritePos
         */
         disableAltGameMode: function(spritePos) {
          // Clear existing horizon objects.
          this.clouds = [];
          this.backgroundEls = [];
      
          this.altGameModeActive = false;
          this.spritePos = spritePos;
      
          Obstacle.types = Runner.spriteDefinition.OBSTACLES;
      
          Obstacle.MAX_GAP_COEFFICIENT = Runner.spriteDefinition.MAX_GAP_COEFFICIENT;
          Obstacle.MAX_OBSTACLE_LENGTH = Runner.spriteDefinition.MAX_OBSTACLE_LENGTH;
      
          BackgroundEl.config = Runner.spriteDefinition.BACKGROUND_EL_CONFIG;
      
          this.horizonLines = [];
          for (let i = 0; i < Runner.spriteDefinition.LINES.length; i++) {
            this.horizonLines.push(
                new HorizonLine(this.canvas, Runner.spriteDefinition.LINES[i]));
          }
          this.reset();
        },
      
        /**
         * @param {number} deltaTime
         * @param {number} currentSpeed
         * @param {boolean} updateObstacles Used as an override to prevent
         *     the obstacles from being updated / added. This happens in the
         *     ease in section.
         */
        update(deltaTime, currentSpeed, updateObstacles) {
          this.runningTime += deltaTime;
      
          if (this.altGameModeActive) {
            this.updateBackgroundEls(deltaTime, currentSpeed);
          }
      
          for (let i = 0; i < this.horizonLines.length; i++) {
            this.horizonLines[i].update(deltaTime, currentSpeed);
          }
      
          if (!this.altGameModeActive || Runner.spriteDefinition.HAS_CLOUDS) {
            this.nightMode.update();
            this.updateClouds(deltaTime, currentSpeed);
          }
      
          if (updateObstacles) {
            this.updateObstacles(deltaTime, currentSpeed);
          }
        },
      
        /**
         * Update background element positions. Also handles creating new elements.
         * @param {number} elSpeed
         * @param {Array<Object>} bgElArray
         * @param {number} maxBgEl
         * @param {Function} bgElAddFunction
         * @param {number} frequency
         */
        updateBackgroundEl(elSpeed, bgElArray, maxBgEl, bgElAddFunction, frequency) {
          const numElements = bgElArray.length;
      
          if (numElements) {
            for (let i = numElements - 1; i >= 0; i--) {
              bgElArray[i].update(elSpeed);
            }
      
            const lastEl = bgElArray[numElements - 1];
      
            // Check for adding a new element.
            if (numElements < maxBgEl &&
                (this.dimensions.WIDTH - lastEl.xPos) > lastEl.gap &&
                frequency > Math.random()) {
              bgElAddFunction();
            }
          } else {
            bgElAddFunction();
          }
        },
      
        /**
         * Update the cloud positions.
         * @param {number} deltaTime
         * @param {number} speed
         */
        updateClouds(deltaTime, speed) {
          const elSpeed = this.cloudSpeed / 1000 * deltaTime * speed;
          this.updateBackgroundEl(
              elSpeed, this.clouds, this.config.MAX_CLOUDS, this.addCloud.bind(this),
              this.cloudFrequency);
      
          // Remove expired elements.
          this.clouds = this.clouds.filter((obj) => !obj.remove);
        },
      
        /**
         * Update the background element positions.
         * @param {number} deltaTime
         * @param {number} speed
         */
        updateBackgroundEls(deltaTime, speed) {
          this.updateBackgroundEl(
              deltaTime, this.backgroundEls, BackgroundEl.config.MAX_BG_ELS,
              this.addBackgroundEl.bind(this), this.cloudFrequency);
      
          // Remove expired elements.
          this.backgroundEls = this.backgroundEls.filter((obj) => !obj.remove);
        },
      
        /**
         * Update the obstacle positions.
         * @param {number} deltaTime
         * @param {number} currentSpeed
         */
        updateObstacles(deltaTime, currentSpeed) {
          const updatedObstacles = this.obstacles.slice(0);
      
          for (let i = 0; i < this.obstacles.length; i++) {
            const obstacle = this.obstacles[i];
            obstacle.update(deltaTime, currentSpeed);
      
            // Clean up existing obstacles.
            if (obstacle.remove) {
              updatedObstacles.shift();
            }
          }
          this.obstacles = updatedObstacles;
      
          if (this.obstacles.length > 0) {
            const lastObstacle = this.obstacles[this.obstacles.length - 1];
      
            if (lastObstacle && !lastObstacle.followingObstacleCreated &&
                lastObstacle.isVisible() &&
                (lastObstacle.xPos + lastObstacle.width + lastObstacle.gap) <
                this.dimensions.WIDTH) {
              this.addNewObstacle(currentSpeed);
              lastObstacle.followingObstacleCreated = true;
            }
          } else {
            // Create new obstacles.
            this.addNewObstacle(currentSpeed);
          }
        },
      
        removeFirstObstacle() {
          this.obstacles.shift();
        },
      
        /**
         * Add a new obstacle.
         * @param {number} currentSpeed
         */
        addNewObstacle(currentSpeed) {
          const obstacleCount = Obstacle.types.length - 1;
          const obstacleTypeIndex = getRandomNum(0, obstacleCount);
          const obstacleType = Obstacle.types[obstacleTypeIndex];
      
          // Check for multiples of the same type of obstacle.
          // Also check obstacle is available at current speed.
          if (this.duplicateObstacleCheck(obstacleType.type) ||
              currentSpeed < obstacleType.minSpeed) {
            this.addNewObstacle(currentSpeed);
          } else {
            const obstacleSpritePos = this.spritePos[obstacleType.type];
      
            this.obstacles.push(new Obstacle(
                this.canvasCtx, obstacleType, obstacleSpritePos, this.dimensions,
                this.gapCoefficient, currentSpeed, obstacleType.width,
                this.altGameModeActive));
      
            this.obstacleHistory.unshift(obstacleType.type);
      
            if (this.obstacleHistory.length > 1) {
              this.obstacleHistory.splice(Runner.config.MAX_OBSTACLE_DUPLICATION);
            }
          }
        },
      
        /**
         * Returns whether the previous two obstacles are the same as the next one.
         * Maximum duplication is set in config value MAX_OBSTACLE_DUPLICATION.
         * @return {boolean}
         */
        duplicateObstacleCheck(nextObstacleType) {
          let duplicateCount = 0;
      
          for (let i = 0; i < this.obstacleHistory.length; i++) {
            duplicateCount =
                this.obstacleHistory[i] === nextObstacleType ? duplicateCount + 1 : 0;
          }
          return duplicateCount >= Runner.config.MAX_OBSTACLE_DUPLICATION;
        },
      
        /**
         * Reset the horizon layer.
         * Remove existing obstacles and reposition the horizon line.
         */
        reset() {
          this.obstacles = [];
          for (let l = 0; l < this.horizonLines.length; l++) {
            this.horizonLines[l].reset();
          }
      
          this.nightMode.reset();
        },
      
        /**
         * Update the canvas width and scaling.
         * @param {number} width Canvas width.
         * @param {number} height Canvas height.
         */
        resize(width, height) {
          this.canvas.width = width;
          this.canvas.height = height;
        },
      
        /**
         * Add a new cloud to the horizon.
         */
        addCloud() {
          this.clouds.push(new Cloud(this.canvas, this.spritePos.CLOUD,
              this.dimensions.WIDTH));
        },
      
        /**
         * Add a random background element to the horizon.
         */
        addBackgroundEl() {
          const backgroundElTypes =
              Object.keys(Runner.spriteDefinition.BACKGROUND_EL);
      
          if (backgroundElTypes.length > 0) {
            let index = getRandomNum(0, backgroundElTypes.length - 1);
            let type = backgroundElTypes[index];
      
            // Add variation if available.
            while (type == this.lastEl && backgroundElTypes.length > 1) {
              index = getRandomNum(0, backgroundElTypes.length - 1);
              type = backgroundElTypes[index];
            }
      
            this.lastEl = type;
            this.backgroundEls.push(new BackgroundEl(
                this.canvas, this.spritePos.BACKGROUND_EL, this.dimensions.WIDTH,
                type));
          }
        },
      };
      
      /**
       * Obstacle definitions.
       * minGap: minimum pixel space between obstacles.
       * multipleSpeed: Speed at which multiples are allowed.
       * speedOffset: speed faster / slower than the horizon.
       * minSpeed: Minimum speed which the obstacle can make an appearance.
       *
       * @typedef {{
       *   type: string,
       *   width: number,
       *   height: number,
       *   yPos: number,
       *   multipleSpeed: number,
       *   minGap: number,
       *   minSpeed: number,
       *   collisionBoxes: Array<CollisionBox>,
       * }}
       */
      let ObstacleType;
      
      /**
       * T-Rex runner sprite definitions.
       */
      Runner.spriteDefinitionByType = {
        original: {
          LDPI: {
            BACKGROUND_EL: {x: 86, y: 2},
            CACTUS_LARGE: {x: 332, y: 2},
            CACTUS_SMALL: {x: 228, y: 2},
            OBSTACLE_2: {x: 332, y: 2},
            OBSTACLE: {x: 228, y: 2},
            CLOUD: {x: 86, y: 2},
            HORIZON: {x: 2, y: 54},
            MOON: {x: 484, y: 2},
            PTERODACTYL: {x: 134, y: 2},
            RESTART: {x: 2, y: 68},
            TEXT_SPRITE: {x: 655, y: 2},
            TREX: {x: 848, y: 2},
            STAR: {x: 645, y: 2},
            ALT_GAME_END: {x: 121, y: 2},
          },
          HDPI: {
            BACKGROUND_EL: {x: 166, y: 2},
            CACTUS_LARGE: {x: 652, y: 2},
            CACTUS_SMALL: {x: 446, y: 2},
            OBSTACLE_2: {x: 652, y: 2},
            OBSTACLE: {x: 446, y: 2},
            CLOUD: {x: 166, y: 2},
            HORIZON: {x: 2, y: 104},
            MOON: {x: 954, y: 2},
            PTERODACTYL: {x: 260, y: 2},
            RESTART: {x: 2, y: 130},
            TEXT_SPRITE: {x: 1294, y: 2},
            TREX: {x: 1678, y: 2},
            STAR: {x: 1276, y: 2},
            ALT_GAME_END: {x: 242, y: 4},
          },
          MAX_GAP_COEFFICIENT: 1.5,
          MAX_OBSTACLE_LENGTH: 3,
          HAS_CLOUDS: 1,
          BOTTOM_PAD: 10,
          TREX: {
            WAITING_1: {x: 44, w: 44, h: 47, xOffset: 0},
            WAITING_2: {x: 0, w: 44, h: 47, xOffset: 0},
            RUNNING_1: {x: 88, w: 44, h: 47, xOffset: 0},
            RUNNING_2: {x: 132, w: 44, h: 47, xOffset: 0},
            JUMPING: {x: 0, w: 44, h: 47, xOffset: 0},
            CRASHED: {x: 220, w: 44, h: 47, xOffset: 0},
            DUCKING_1: {x: 264}, // To reset ducking frames.
            DUCKING_2: {x: 323}, // To reset ducking frames.
            COLLISION_BOXES: [
              new CollisionBox(22, 0, 17, 16),
              new CollisionBox(1, 18, 30, 9),
              new CollisionBox(10, 35, 14, 8),
              new CollisionBox(1, 24, 29, 5),
              new CollisionBox(5, 30, 21, 4),
              new CollisionBox(9, 34, 15, 4),
            ],
          },
          /** @type {Array<ObstacleType>} */
          OBSTACLES: [
            {
              type: 'CACTUS_SMALL',
              width: 17,
              height: 35,
              yPos: 105,
              multipleSpeed: 4,
              minGap: 120,
              minSpeed: 0,
              collisionBoxes: [
                new CollisionBox(0, 7, 5, 27),
                new CollisionBox(4, 0, 6, 34),
                new CollisionBox(10, 4, 7, 14),
              ],
            },
            {
              type: 'CACTUS_LARGE',
              width: 25,
              height: 50,
              yPos: 90,
              multipleSpeed: 7,
              minGap: 120,
              minSpeed: 0,
              collisionBoxes: [
                new CollisionBox(0, 12, 7, 38),
                new CollisionBox(8, 0, 7, 49),
                new CollisionBox(13, 10, 10, 38),
              ],
            },
            {
              type: 'PTERODACTYL',
              width: 46,
              height: 40,
              yPos: [100, 75, 50],    // Variable height.
              multipleSpeed: 999,
              minSpeed: 8.5,
              minGap: 150,
              collisionBoxes: [
                new CollisionBox(15, 15, 16, 5),
                new CollisionBox(18, 21, 24, 6),
                new CollisionBox(2, 14, 4, 3),
                new CollisionBox(6, 10, 4, 7),
                new CollisionBox(10, 8, 6, 9),
              ],
              numFrames: 2,
              frameRate: 1000 / 6,
              speedOffset: .8,
            },
          ],
          BACKGROUND_EL: {
            'CLOUD': {
              HEIGHT: 14,
              MAX_CLOUD_GAP: 400,
              MAX_SKY_LEVEL: 30,
              MIN_CLOUD_GAP: 100,
              MIN_SKY_LEVEL: 71,
              OFFSET: 4,
              WIDTH: 46,
              X_POS: 1,
              Y_POS: 120,
            },
          },
          BACKGROUND_EL_CONFIG: {
            MAX_BG_ELS: 1,
            MAX_GAP: 400,
            MIN_GAP: 100,
            POS: 0,
            SPEED: 0.5,
            Y_POS: 125,
          },
          LINES: [
            {SOURCE_X: 2, SOURCE_Y: 52, WIDTH: 600, HEIGHT: 12, YPOS: 127},
          ],
          // Show sprite when crashed in alternative game mode.
          /*ALT_GAME_END_CONFIG: {
            WIDTH: 44,
            HEIGHT: 47,
            X_OFFSET: 0,
            Y_OFFSET: 0,
          },*/
        },
      };
      var loadTimeData;
      class LoadTimeData {
        constructor() {
          this.data_ = null
        }
        set data(value) {
          expect(!this.data_, "Re-setting data.");
          this.data_ = value
        }
        valueExists(id) {
          return id in this.data_
        }
        getValue(id) {
          expect(this.data_, "No data. Did you remember to include strings.js?");
          const value = this.data_[id];
          expect(typeof value !== "undefined", "Could not find value for " + id);
          return value
        }
        getString(id) {
          const value = this.getValue(id);
          expectIsType(id, value, "string");
          return value
        }
        getStringF(id, var_args) {
          const value = this.getString(id);
          if(!value) {
            return ""
          }
          const args = Array.prototype.slice.call(arguments);
          args[0] = value;
          return this.substituteString.apply(this, args)
        }
        substituteString(label, var_args) {
          const varArgs = arguments;
          return label.replace(/\$(.|$|\n)/g, (function(m) {
            expect(m.match(/\$[$1-9]/), "Unescaped $ found in localized string.");
            return m === "$$" ? "$" : varArgs[m[1]]
          }))
        }
        getBoolean(id) {
          const value = this.getValue(id);
          expectIsType(id, value, "boolean");
          return value
        }
        getInteger(id) {
          const value = this.getValue(id);
          expectIsType(id, value, "number");
          expect(value === Math.floor(value), "Number isn't integer: " + value);
          return value
        }
        overrideValues(replacements) {
          expect(typeof replacements === "object", "Replacements must be a dictionary object.");
          for(const key in replacements) {
            this.data_[key] = replacements[key]
          }
        }
      }
      function expect(condition, message) {
        if(!condition) {
          throw new Error("Unexpected condition on " + document.location.href + ": " + message)
        }
      }
      function expectIsType(id, value, type) {
        expect(typeof value === type, "[" + value + "] (" + id + ") is not a " + type)
      }
      expect(!loadTimeData, "should only include this file once");
      loadTimeData = new LoadTimeData;
      window.loadTimeData = loadTimeData;
      const pageData = {
        "dinoGameA11yAriaLabel": "Dino game, play",
        "dinoGameA11yDescription": "Dino game. A pixelated dinosaur dodges cacti and pterodactyls as it runs across a desolate landscape. When you hear an audio cue, press space to jump over obstacles.",
        "dinoGameA11yGameOver": "Game over, your score is $1.",
        "dinoGameA11yHighScore": "Your highest score is $1.",
        "dinoGameA11yJump": "Jump!",
        "dinoGameA11yStartGame": "Game started.",
        "errorCode":"",
        "fontfamily": "'Segoe UI', Tahoma, sans-serif",
        "fontfamilyMd": "'Segoe UI', Tahoma, sans-serif",
        "fontsize": "75%",
        "heading": {
          "hostName": "dino",
          "msg": "Press space to play"
        },
        "iconClass": "icon-offline",
        "language": "en",
        "textdirection": "ltr",
        "title": document.title,
        "altSprites1x": "data:image/png;base64,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",
      };
      loadTimeData.data = pageData;
    </script>  
  </head>
  <body id="t" class="neterror" style="font-family: 'Segoe UI', Tahoma, sans-serif; font-size: 75%" jstcache="0">
    <div id="main-frame-error" class="interstitial-wrapper" jstcache="0">
      <div id="main-content" jstcache="0" autofocus>
        <div class="icon icon-offline" jstcache="0" style="visibility: hidden;"></div>
        <div id="main-message" jstcache="0">
          <h1 jstcache="0">
            <span jsselect="heading" jsvalues=".innerHTML:msg" jstcache="9">Press space to play</span>
            <a id="error-information-button" class="hidden" onclick="toggleErrorInformationPopup();" jstcache="0"></a>
          </h1>
          <p jsselect="summary" jsvalues=".innerHTML:msg" jstcache="1" style="display: none;"></p>
          <div id="error-information-popup-container" jstcache="0">
            <div id="error-information-popup" jstcache="0">
              <div id="error-information-popup-box" jstcache="0">
                <div id="error-information-popup-content" jstcache="0">
                  <div id="suggestions-list" style="display:none" jsdisplay="(suggestionsSummaryList &amp;&amp; suggestionsSummaryList.length)" jstcache="16">
                    <p jsvalues=".innerHTML:suggestionsSummaryListHeader" jstcache="18"></p>
                    <ul jsvalues=".className:suggestionsSummaryList.length == 1 ? 'single-suggestion' : ''" jstcache="19">
                      <li jsselect="suggestionsSummaryList" jsvalues=".innerHTML:summary" jstcache="21"></li>
                    </ul>
                  </div>
                  <div class="error-code" jscontent="errorCode" jstcache="17"></div>
                  <p id="error-information-popup-close" jstcache="0">
                    <a class="link-button" jscontent="closeDescriptionPopup" onclick="toggleErrorInformationPopup();" jstcache="20">null</a>
                  </p>
                </div>
              </div>
            </div>
          </div>
          <div id="download-links-wrapper" class="hidden" jstcache="0">
            <div id="download-link-wrapper" jstcache="0">
              <a id="download-link" class="link-button" onclick="downloadButtonClick()" jsselect="downloadButton" jscontent="msg" jsvalues=".disabledText:disabledMsg" jstcache="6" style="display: none;"></a>
            </div>
            <div id="download-link-clicked-wrapper" class="hidden" jstcache="0">
              <div id="download-link-clicked" class="link-button" jsselect="downloadButton" jscontent="disabledMsg" jstcache="11" style="display: none;"></div>
            </div>
          </div>
          <div id="save-page-for-later-button" class="hidden" jstcache="0">
            <a class="link-button" onclick="savePageLaterClick()" jsselect="savePageLater" jscontent="savePageMsg" jstcache="10" style="display: none;"></a>
          </div>
          <div id="cancel-save-page-button" class="hidden" onclick="cancelSavePageClick()" jsselect="savePageLater" jsvalues=".innerHTML:cancelMsg" jstcache="4" style="display: none;"></div>
          <div id="offline-content-list" class="list-hidden" hidden="" jstcache="0">
            <div id="offline-content-list-visibility-card" onclick="toggleOfflineContentListVisibility(true)" jstcache="0">
              <div id="offline-content-list-title" jsselect="offlineContentList" jscontent="title" jstcache="12" style="display: none;"></div>
              <div jstcache="0">
                <div id="offline-content-list-show-text" jsselect="offlineContentList" jscontent="showText" jstcache="14" style="display: none;"></div>
                <div id="offline-content-list-hide-text" jsselect="offlineContentList" jscontent="hideText" jstcache="15" style="display: none;"></div>
              </div>
            </div>
            <div id="offline-content-suggestions" jstcache="0"></div>
            <div id="offline-content-list-action" jstcache="0">
              <a class="link-button" onclick="launchDownloadsPage()" jsselect="offlineContentList" jscontent="actionText" jstcache="13" style="display: none;"></a>
            </div>
          </div>
        </div>
      </div>
      <div id="buttons" class="nav-wrapper suggested-left" jstcache="0">
        <div id="control-buttons" hidden="" jstcache="0">
          <button id="reload-button" class="blue-button text-button" onclick="reloadButtonClick(this.url);" jsselect="reloadButton" jsvalues=".url:reloadUrl" jscontent="msg" jstcache="5" style="display: none;"></button>
          <button id="download-button" class="blue-button text-button" onclick="downloadButtonClick()" jsselect="downloadButton" jscontent="msg" jsvalues=".disabledText:disabledMsg" jstcache="6" style="display: none;"></button>
        </div>
        <button id="details-button" class="secondary-button text-button small-link singular" onclick="detailsButtonClick(); toggleHelpBox()" jscontent="details" jsdisplay="(suggestionsDetails &amp;&amp; suggestionsDetails.length > 0) || diagnose" jsvalues=".detailsText:details; .hideDetailsText:hideDetails;" jstcache="2" style="display: none;"></button>
      </div>
      <div id="details" class="hidden" jstcache="0">
        <div class="suggestions" jsselect="suggestionsDetails" jstcache="3" style="display: none;">
          <div class="suggestion-header" jsvalues=".innerHTML:header" jstcache="7"></div>
          <div class="suggestion-body" jsvalues=".innerHTML:body" jstcache="8"></div>
        </div>
      </div>
      <div role="application" tabindex="0" title="Dino game, play" class="runner-container">
        <canvas class="runner-canvas" width="600" height="150" style="width: 600px; height: 150px;"></canvas>
        <span class="offline-runner-live-region" aria-live="assertive">Dino game. A pixelated dinosaur dodges cacti and pterodactyls as it runs across a desolate landscape. When you hear an audio cue, press space to jump over obstacles.</span>
      </div>
    </div>
    <div id="sub-frame-error" jstcache="0">
      <div class="icon" jstcache="0"></div>
      <div id="sub-frame-error-details" jsselect="summary" jsvalues=".innerHTML:msg" jstcache="1" style="display: none;"></div>
    </div>
    <div id="offline-resources" jstcache="0">
      <img id="offline-resources-1x" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABNEAAABkCAYAAACo5KarAAAACXBIWXMAAAsTAAALEwEAmpwYAAAE7mlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgOS4xLWMwMDIgNzkuZGJhM2RhMywgMjAyMy8xMi8xMy0wNTowNjo0OSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDI1LjcgKFdpbmRvd3MpIiB4bXA6Q3JlYXRlRGF0ZT0iMjAyNC0wNC0yM1QyMToyNTowMC0wNzowMCIgeG1wOk1vZGlmeURhdGU9IjIwMjQtMDQtMjNUMjE6MjY6MjAtMDc6MDAiIHhtcDpNZXRhZGF0YURhdGU9IjIwMjQtMDQtMjNUMjE6MjY6MjAtMDc6MDAiIGRjOmZvcm1hdD0iaW1hZ2UvcG5nIiBwaG90b3Nob3A6Q29sb3JNb2RlPSIzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjY1ZGZlZGU0LTViYzktZGE0Yi1hMzcyLTljZWNmNjc5YjNjYiIgeG1wTU06RG9jdW1lbnRJRD0i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" jstcache="0">
      <img id="offline-resources-2x" src="data:image/png;base64,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" jstcache="0">
      <template id="audio-resources" jstcache="0">
        <audio id="offline-sound-press" src="data:audio/mpeg;base64,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"></audio>
        <audio id="offline-sound-hit" src="data:audio/mpeg;base64,T2dnUwACAAAAAAAAAABVDxppAAAAABYzHfUBHgF2b3JiaXMAAAAAAkSsAAD/////AHcBAP////+4AU9nZ1MAAAAAAAAAAAAAVQ8aaQEAAAC9PVXbEEf//////////////////+IDdm9yYmlzNwAAAEFPOyBhb1R1ViBiNSBbMjAwNjEwMjRdIChiYXNlZCBvbiBYaXBoLk9yZydzIGxpYlZvcmJpcykAAAAAAQV2b3JiaXMlQkNWAQBAAAAkcxgqRqVzFoQQGkJQGeMcQs5r7BlCTBGCHDJMW8slc5AhpKBCiFsogdCQVQAAQAAAh0F4FISKQQghhCU9WJKDJz0IIYSIOXgUhGlBCCGEEEIIIYQQQgghhEU5aJKDJ0EIHYTjMDgMg+U4+ByERTlYEIMnQegghA9CuJqDrDkIIYQkNUhQgwY56ByEwiwoioLEMLgWhAQ1KIyC5DDI1IMLQoiag0k1+BqEZ0F4FoRpQQghhCRBSJCDBkHIGIRGQViSgwY5uBSEy0GoGoQqOQgfhCA0ZBUAkAAAoKIoiqIoChAasgoAyAAAEEBRFMdxHMmRHMmxHAsIDVkFAAABAAgAAKBIiqRIjuRIkiRZkiVZkiVZkuaJqizLsizLsizLMhAasgoASAAAUFEMRXEUBwgNWQUAZAAACKA4iqVYiqVoiueIjgiEhqwCAIAAAAQAABA0Q1M8R5REz1RV17Zt27Zt27Zt27Zt27ZtW5ZlGQgNWQUAQAAAENJpZqkGiDADGQZCQ1YBAAgAAIARijDEgNCQVQAAQAAAgBhKDqIJrTnfnOOgWQ6aSrE5HZxItXmSm4q5Oeecc87J5pwxzjnnnKKcWQyaCa0555zEoFkKmgmtOeecJ7F50JoqrTnnnHHO6WCcEcY555wmrXmQmo21OeecBa1pjppLsTnnnEi5eVKbS7U555xzzjnnnHPOOeec6sXpHJwTzjnnnKi9uZab0MU555xPxunenBDOOeecc84555xzzjnnnCA0ZBUAAAQAQBCGjWHcKQjS52ggRhFiGjLpQffoMAkag5xC6tHoaKSUOggllXFSSicIDVkFAAACAEAIIYUUUkghhRRSSCGFFGKIIYYYcsopp6CCSiqpqKKMMssss8wyyyyzzDrsrLMOOwwxxBBDK63EUlNtNdZYa+4555qDtFZaa621UkoppZRSCkJDVgEAIAAABEIGGWSQUUghhRRiiCmnnHIKKqiA0JBVAAAgAIAAAAAAT/Ic0REd0REd0REd0REd0fEczxElURIlURIt0zI101NFVXVl15Z1Wbd9W9iFXfd93fd93fh1YViWZVmWZVmWZVmWZVmWZVmWIDRkFQAAAgAAIIQQQkghhRRSSCnGGHPMOegklBAIDVkFAAACAAgAAABwFEdxHMmRHEmyJEvSJM3SLE/zNE8TPVEURdM0VdEVXVE3bVE2ZdM1XVM2XVVWbVeWbVu2dduXZdv3fd/3fd/3fd/3fd/3fV0HQkNWAQASAAA6kiMpkiIpkuM4jiRJQGjIKgBABgBAAACK4iiO4ziSJEmSJWmSZ3mWqJma6ZmeKqpAaMgqAAAQAEAAAAAAAACKpniKqXiKqHiO6IiSaJmWqKmaK8qm7Lqu67qu67qu67qu67qu67qu67qu67qu67qu67qu67qu67quC4SGrAIAJAAAdCRHciRHUiRFUiRHcoDQkFUAgAwAgAAAHMMxJEVyLMvSNE/zNE8TPdETPdNTRVd0gdCQVQAAIACAAAAAAAAADMmwFMvRHE0SJdVSLVVTLdVSRdVTVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTdM0TRMIDVkJAJABAKAQW0utxdwJahxi0nLMJHROYhCqsQgiR7W3yjGlHMWeGoiUURJ7qihjiknMMbTQKSet1lI6hRSkmFMKFVIOWiA0ZIUAEJoB4HAcQLIsQLI0AAAAAAAAAJA0DdA8D7A8DwAAAAAAAAAkTQMsTwM0zwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQNI0QPM8QPM8AAAAAAAAANA8D/BEEfBEEQAAAAAAAAAszwM80QM8UQQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwNE0QPM8QPM8AAAAAAAAALA8D/BEEfA8EQAAAAAAAAA0zwM8UQQ8UQQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAABDgAAAQYCEUGrIiAIgTADA4DjQNmgbPAziWBc+D50EUAY5lwfPgeRBFAAAAAAAAAAAAADTPg6pCVeGqAM3zYKpQVaguAAAAAAAAAAAAAJbnQVWhqnBdgOV5MFWYKlQVAAAAAAAAAAAAAE8UobpQXbgqwDNFuCpcFaoLAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAABhwAAAIMKEMFBqyIgCIEwBwOIplAQCA4ziWBQAAjuNYFgAAWJYligAAYFmaKAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAGHAAAAgwoQwUGrISAIgCADAoimUBy7IsYFmWBTTNsgCWBtA8gOcBRBEACAAAKHAAAAiwQVNicYBCQ1YCAFEAAAZFsSxNE0WapmmaJoo0TdM0TRR5nqZ5nmlC0zzPNCGKnmeaEEXPM02YpiiqKhBFVRUAAFDgAAAQYIOmxOIAhYasBABCAgAMjmJZnieKoiiKpqmqNE3TPE8URdE0VdVVaZqmeZ4oiqJpqqrq8jxNE0XTFEXTVFXXhaaJommaommqquvC80TRNE1TVVXVdeF5omiapqmqruu6EEVRNE3TVFXXdV0giqZpmqrqurIMRNE0VVVVXVeWgSiapqqqquvKMjBN01RV15VdWQaYpqq6rizLMkBVXdd1ZVm2Aarquq4ry7INcF3XlWVZtm0ArivLsmzbAgAADhwAAAKMoJOMKouw0YQLD0ChISsCgCgAAMAYphRTyjAmIaQQGsYkhBJCJiWVlEqqIKRSUikVhFRSKiWjklJqKVUQUikplQpCKqWVVAAA2IEDANiBhVBoyEoAIA8AgCBGKcYYYwwyphRjzjkHlVKKMeeck4wxxphzzkkpGWPMOeeklIw555xzUkrmnHPOOSmlc84555yUUkrnnHNOSiklhM45J6WU0jnnnBMAAFTgAAAQYKPI5gQjQYWGrAQAUgEADI5jWZqmaZ4nipYkaZrneZ4omqZmSZrmeZ4niqbJ8zxPFEXRNFWV53meKIqiaaoq1xVF0zRNVVVVsiyKpmmaquq6ME3TVFXXdWWYpmmqquu6LmzbVFXVdWUZtq2aqiq7sgxcV3Vl17aB67qu7Nq2AADwBAcAoAIbVkc4KRoLLDRkJQCQAQBAGIOMQgghhRBCCiGElFIICQAAGHAAAAgwoQwUGrISAEgFAACQsdZaa6211kBHKaWUUkqpcIxSSimllFJKKaWUUkoppZRKSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoFAC5VOADoPtiwOsJJ0VhgoSErAYBUAADAGKWYck5CKRVCjDkmIaUWK4QYc05KSjEWzzkHoZTWWiyecw5CKa3FWFTqnJSUWoqtqBQyKSml1mIQwpSUWmultSCEKqnEllprQQhdU2opltiCELa2klKMMQbhg4+xlVhqDD74IFsrMdVaAABmgwMARIINqyOcFI0FFhqyEgAICQAgjFGKMcYYc8455yRjjDHmnHMQQgihZIwx55xzDkIIIZTOOeeccxBCCCGEUkrHnHMOQgghhFBS6pxzEEIIoYQQSiqdcw5CCCGEUkpJpXMQQgihhFBCSSWl1DkIIYQQQikppZRCCCGEEkIoJaWUUgghhBBCKKGklFIKIYRSQgillJRSSimFEEoIpZSSUkkppRJKCSGEUlJJKaUUQggllFJKKimllEoJoYRSSimlpJRSSiGUUEIpBQAAHDgAAAQYQScZVRZhowkXHoBCQ1YCAGQAAJSyUkoorVVAIqUYpNpCR5mDFHOJLHMMWs2lYg4pBq2GyjGlGLQWMgiZUkxKCSV1TCknLcWYSuecpJhzjaVzEAAAAEEAgICQAAADBAUzAMDgAOFzEHQCBEcbAIAgRGaIRMNCcHhQCRARUwFAYoJCLgBUWFykXVxAlwEu6OKuAyEEIQhBLA6ggAQcnHDDE294wg1O0CkqdSAAAAAAAAwA8AAAkFwAERHRzGFkaGxwdHh8gISIjJAIAAAAAAAYAHwAACQlQERENHMYGRobHB0eHyAhIiMkAQCAAAIAAAAAIIAABAQEAAAAAAACAAAABARPZ2dTAATCMAAAAAAAAFUPGmkCAAAAhlAFnjkoHh4dHx4pKHA1KjEqLzIsNDQqMCveHiYpczUpLS4sLSg3MicsLCsqJTIvJi0sKywkMjbgWVlXWUa00CqtQNVCq7QC1aoNVPXg9Xldx3nn5tixvV6vb7TX+hg7cK21QYgAtNJFphRUtpUuMqWgsqrasj2IhOA1F7LFMdFaWzkAtNBFpisIQgtdZLqCIKjqAAa9WePLkKr1MMG1FlwGtNJFTSkIcitd1JSCIKsCAQWISK0Cyzw147T1tAK00kVNKKjQVrqoCQUVqqr412m+VKtZf9h+TDaaztAAtNJFzVQQhFa6qJkKgqAqUGgtuOa2Se5l6jeXGSqnLM9enqnLs5dn6m7TptWUiVUVN4jhUz9//lzx+Xw+X3x8fCQSiWggDAA83UXF6/vpLipe3zsCULWMBE5PMTBMlsv39/f39/f39524nZ13CDgaRFuLYTbaWgyzq22MzEyKolIpst50Z9PGqqJSq8T2++taLf3+oqg6btyouhEjYlxFjXxex1wCBFxcv+PmzG1uc2bKyJFLLlkizZozZ/ZURpZs2TKiWbNnz5rKyJItS0akWbNnzdrIyJJtxmCczpxOATRRhoPimyjDQfEfIFMprQDU3WFYbXZLZZxMhxrGyRh99Uqel55XEk+9efP7I/FU/8Ojew4JNN/rTq6b73Un1x+AVSsCWD2tNqtpGOM4DOM4GV7n5th453cXNGcfAYQKTFEOguKnKAdB8btRLxNBWUrViLoY1/q1er+Q9xkvZM/IjaoRf30xu3HLnr61fu3UBDRZHZdqsjoutQeAVesAxNMTw2rR66X/Ix6/T5tx80+t/D67ipt/q5XfJzTfa03Wzfdak/UeAEpZawlsbharxTBVO1+c2nm/7/f1XR1dY8XaKWMH3aW9xvEFRFEksXgURRKLn7VamSFRVnYXg0C2Zo2MNE3+57u+e3NFlVev1uufX6nU3Lnf9d1j4wE03+sObprvdQc3ewBYFIArAtjdrRaraRivX7x+8VrbHIofG0n6cFwtNFKYBzxXA2j4uRpAw7dJRkSETBkZV1V1o+N0Op1WhmEyDOn36437RbKvl7zz838wgn295Iv8/Ac8UaRIPFGkSHyAzCItAXY3dzGsNueM6VDDOJkOY3QYX008L6vnfZp/3qf559VQL3Xm1SEFNN2fiMA03Z+IwOwBoKplAKY4TbGIec0111x99dXr9XrjZ/nzdSWXBekAHEsWp4ljyeI0sVs2FEGiLFLj7rjxeqG8Pm+tX/uW90b+DX31bVTF/I+Ut+/sM1IA/MyILvUzI7rUbpNqyIBVjSDGVV/Jo/9H6G/jq+5y3Pzb7P74Znf5ffZtApI5/fN5SAcHjIhB5vTP5yEdHDAiBt4oK/WGeqUMMspeTNsGk/H/PziIgCrG1Rijktfreh2vn4DH78WXa25yZkizZc9oM7JmaYeZM6bJOJkOxmE69Hmp/q/k0fvVRLln3H6fXcXNPt78W638Ptlxsytv/pHyW7Pfp1Xc7L5XfqvZb5MdN7vy5p/u8lut/D6t4mb3vfmnVn6bNt9nV3Hzj1d+q9lv02bc7Mqbf6vZb+N23OzKm73u8lOz3+fY3uwqLv1022+THTepN38yf7XyW1aX8YqjACWfDTiAA+BQALTURU0oCFpLXdSEgqAJpAKxrLtzybNt1Go5VeJAASzRnh75Eu3pke8BYNWiCIBVLdgsXMqlXBJijDGW2Sj5lUqlSJFpPN9fAf08318B/ewBUMUiA3h4YGIaooZrfn5+fn5+fn5+fn6mtQYKcQE8WVg5YfJkYeWEyWqblCIiiqKoVGq1WqxWWa3X6/V6vVoty0zrptXq9/u4ccS4GjWKGxcM6ogaNWpUnoDf73Xd3OQml2xZMhJNM7Nmz54zZ/bsWbNmphVJRpYs2bJly5YtS0YSoWlm1uzZc+bMnj17ZloATNNI4PbTNBK4/W5jlJGglFJWI4hR/levXr06RuJ5+fLly6Ln1atXxxD18uXLKnr+V8cI8/M03+vErpvvdWLXewBYxVoC9bBZDcPU3Bevtc399UWNtZH0p4MJZov7AkxThBmYpggzcNVCJqxIRQwiLpNBxxqUt/NvuCqmb2Poa+RftCr7DO3te16HBjzbulL22daVsnsAqKIFwMXVzbCLYdVe9vGovzx9xP7469mk3L05d1+qjyKuPAY8397G2PPtbYztAWDVQgCH09MwTTG+Us67nX1fG5G+0o3YvspGtK+yfBmqAExTJDHQaYokBnrrZZEZkqoa3BjFDJlmGA17PF+qE/GbJd3xm0V38qoYT/aLuTzh6w/ST/j6g/QHYBVgKYHTxcVqGKY5DOM4DNNRO3OXkM0JmAto6AE01xBa5OYaQou8B4BmRssAUNQ0TfP169fv169fvz6XSIZhGIbJixcvXrzIFP7+/3/9evc/wyMAVFM8EEOvpngghr5by8hIsqiqBjXGXx0T4zCdTCfj8PJl1fy83vv7q1fHvEubn5+fnwc84etOrp/wdSfXewBUsRDA5upqMU1DNl+/GNunkTDUGrWzn0BDIC5UUw7CwKspB2HgVzVFSFZ1R9QxU8MkHXvLGV8jKxtjv6J9G0N/MX1fIysbQzTdOlK26daRsnsAWLUGWFxcTQum8Skv93j2KLpfjSeb3fvFmM3xt3L3/mwCPN/2Rvb5tjeyewBULQGmzdM0DMzS3vEVHVu6MVTZGNn3Fe37WjxU2RjqAUxThJGfpggjv1uLDAlVdeOIGNH/1P9Q5/Jxvf49nmyOj74quveLufGb4zzh685unvB1Zzd7AFQAWAhguLpaTFNk8/1i7Ni+Oq5BxQVcGABEVcgFXo+qkAu8vlurZiaoqiNi3N2Z94sXL168ePEiR4wYMWLEiBEjRowYMWLEiBEjAFRVtGm4qqJNw7ceGRkZrGpQNW58OozDOIzDy5dV8/Pz8/Pz8/Pz8/Pz8/Pz8/NlPN/rDr6f73UH33sAVLGUwHRxsxqGaq72+tcvy5LsLLZ5JdBo0BdUU7Qgr6ZoQb4NqKon4PH6zfFknHYYjOqLT9XaWdkYWvQr2vcV7fuK9n3F9AEs3SZSduk2kbJ7AKhqBeDm7maYaujzKS8/0f/UJ/eL7v2ie7/o3rfHk83xBDzdZlLu6TaTcnsAWLUAYHcz1KqivUt7V/ZQZWPoX7TvK9r3a6iyMVSJ6QNMUaSQnaJIIXvrGSkSVTWIihsZpsmYjKJ/8vTxvC6694sxm+PJ5vhbuXu/ADzf6w5+nu91Bz97AFi1lACHm9UwVHPztbbpkiKHJVsy2SAcDURTFhZc0ZSFBdeqNqiKQXwej8dxXrx48eLFixcvXrx4oY3g8/////////+voo3IF3cCRE/xjoLoKd5RsPUCKVN9jt/v8TruMJ1MJ9PJ6E3z8y9fvnz58uXLly+rSp+Z+V+9ejXv7+8eukl9XpcPJED4YJP6vC4fSIDwgWN7vdDrmfT//4PHDfg98ns9/qDHnBxps2RPkuw5ciYZOXPJmSFrllSSNVumJDNLphgno2E6GQ3jUBmPeOn/KP11zY6bfxvfjCu/TSuv/Datustxs0/Njpt9anbc7Nv4yiu/TSuv/Datustxs0/Njpt9aptx82/jm175bVp55bfZ/e5y3OxT24ybfWqbcfNv08orv00rr/w27dfsuNmnthk3+7SVV36bVl75bVqJnUxPzXazT0294mnq2W+TikmmE5LiQb3pAa94mnpFAGxeSf1/jn9mWTgDBjhUUv+f459ZFs6AAQ4AAAAAAIAH/0EYBHEAB6gDzBkAAUxWjEAQk7nWaBZuuKvBN6iqkoMah7sAhnRZ6lFjmllwEgGCAde2zYBzAB5AAH5J/X+Of81ycQZMHI0uqf/P8a9ZLs6AiaMRAAAAAAIAOPgPw0EUEIddhEaDphAAjAhrrgAUlNDwPZKFEPFz2JKV4FqHl6tIxjaQDfQAiJqgZk1GDQgcBuAAfkn9f45/zXLiDBgwuqT+P8e/ZjlxBgwYAQAAAAAAg/8fDBlCDUeGDICqAJAT585AAALkhkHxIHMR3AF8IwmgWZwQhv0DcpcIMeTjToEGKDQAB0CEACgAfkn9f45/LXLiDCiMxpfU/+f41yInzoDCaAwAAAAEg4P/wyANDgAEhDsAujhQcBgAHEakAKBZjwHgANMYAkIDo+L8wDUrrgHpWnPwBBoJGZqDBmBAUAB1QANeOf1/zn53uYQA9ckctMrp/3P2u8slBKhP5qABAAAAAACAIAyCIAiD8DAMwoADzgECAA0wQFMAiMtgo6AATVGAE0gADAQA"></audio>
        <audio id="offline-sound-reached" src="data:audio/mpeg;base64,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"></audio>
      </template>
    </div>
  </body>
</html>
<!--
  extra keys:
  h: toggle hitboxes
  a: toggle alt game mode
  c: toggle autoplay
  x: toggle superspeed
-->
